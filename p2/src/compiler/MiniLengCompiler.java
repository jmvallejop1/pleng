/* Generated By:JavaCC: Do not edit this line. MiniLengCompiler.java */
package compiler;
import java.io.*;
import semantico.*;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.PrintWriter;


public class MiniLengCompiler implements MiniLengCompilerConstants {


  public static class RegistroExpr {
        int valorEnt;
        boolean valorBool;
        char valorChar;
        boolean esVariable = false;
        String cadena;
        Simbolo.Tipo_variable tipo;
        Simbolo.Tipo_simbolo s;
        int tam_vec = -1;
        Simbolo sim = null;

        //Devuelve un Registro expresion booleano 
        public static RegistroExpr BOOL(boolean b) {
                RegistroExpr reg = new RegistroExpr();
                reg.tipo= Simbolo.Tipo_variable.BOOLEANO;
                reg.valorBool = b;
                return reg;
        }
        //Devuelve un Registro de tipo Entero
        public static RegistroExpr ENTERO(String entero) {
                RegistroExpr reg = new RegistroExpr();
                reg.tipo= Simbolo.Tipo_variable.ENTERO;
                reg.valorEnt = Integer.parseInt(entero);
                return reg;
        }
        //Devuelve un Registro de tipo Char
        public static RegistroExpr CHAR(String c) {
                RegistroExpr reg = new RegistroExpr();
                reg.tipo= Simbolo.Tipo_variable.CHAR;
                reg.valorChar = c.charAt(0);
                return reg;
        }

        //Devuelve un Registro de tipo cadena
        public static RegistroExpr CADENA(String c) {
                RegistroExpr reg = new RegistroExpr();
                reg.tipo= Simbolo.Tipo_variable.CADENA;
                reg.cadena = c;
                return reg;
        }

//	//Devuelve un Registro de tipo desconocido
//	public static RegistroExpr DESCONOCIDO() {
//		RegistroExpr reg = new RegistroExpr();
//		reg.tipo = Simbolo.Tipo_variable.DESCONOCIDO;
//		reg.variable = true;
//		return reg;
//	}
//	
        }

  public static Etiqueta et = new Etiqueta();
  //Declaracion print writer para escribir el fichero .code
  public static PrintWriter pw;

  //Declaraciones necesarias para tablla de simbolos
  static int nivel = 0;
  static final int INICIAL = 3;

  //Inicializacion de la direccion para a칦췋adir a la tabla de simbolos

  public static int dir = INICIAL;
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  public static void main(String args []) throws ParseException
  {
    //Pasamos como parametro el fichero que queremos compilar
    //Intentamos leer el fichero 
    try {
          System.out.println(args[0]);
              FileInputStream F = new FileInputStream(args[0]);
              System.setIn(F);
        }catch (Exception e) {
           //Si no encuentra fichero lee de la entrada estandar
            System.out.println("Leyendo de la entrada estandar...");
    }


         try {
                         //TODO: camviar esto por el nombre del fichero + code
                         File cod_inter = new File("C:\u005c\u005cUsers\u005c\u005cJmval\u005c\u005cOneDrive\u005c\u005cEscritorio\u005c\u005cpleng\u005c\u005cp2\u005c\u005ccodigo_intermedio\u005c\u005cpruebas.code");
                 FileWriter fichero_salida = new FileWriter(cod_inter);
                         pw = new PrintWriter(fichero_salida);
                 MiniLengCompiler parser = new MiniLengCompiler(System.in);
                         tabla_simbolos.inicializar_tabla();
                         MiniLengCompiler.programa();
          }catch (TokenMgrError e) {
              try {
                   //gestion de los errores lexicos
                       int linea = SimpleCharStream.getBeginLine();
                       int columna = SimpleCharStream.getBeginColumn();
                       char c = SimpleCharStream.readChar();
                   LexicalErrorManager.printLexicalError(linea,columna,c);
              }catch(Exception ex){}
                }
                //TODO:gestionar excepcion del print writer
                catch (IOException e) { }
         }

/*ANALIZADOR SINTACTICO*/
  static final public void programa() throws ParseException {
  Token programa;
    try {
      jj_consume_token(tPROGRAMA);
      programa = jj_consume_token(tID);
          Simbolo p = new Simbolo();
          p = tabla_simbolos.introducir_programa(programa.image,dir);
          //Escribimos en el fichero de codigo intermedio el programa
          System.out.println("Voy a escribir probrama en .code");

          pw.println("; Programa " + programa.image + ".");
          //Introducimos la primera intruccion de inicio de programa
          String et_p = et.nueva_et();
          pw.println("\u0009ENP  " + et_p);

          //tabla_simbolos.imprimirTabla();

      jj_consume_token(tFIN_SENTENCIA);
      declaracion_variables();
           pw.println("; Comienzo del programa " + programa.image);
      declaracion_acciones();
           pw.println(et_p + ":");
      bloque_sentencias(p, et_p);
                pw.println("; Fin del programa " + programa.image);
        pw.println("LVP");
           pw.close();
    } catch (ParseException e) {
//    System.out.println("1");
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la creacion del programa");
    }
  }

  static final public void declaracion_variables() throws ParseException {
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tENTERO:
        case tBOOLEANO:
        case tCARACTER:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        declaracion();
        jj_consume_token(tFIN_SENTENCIA);
      }
    } catch (ParseException e) {
      //TODO: idea->crear una variable booleana que indique que ha ocurrido un error
          SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la declaracion de variables");
    }
  }

  static final public void declaracion() throws ParseException {
  Simbolo.Tipo_variable tipo;
    tipo = tipo_variables();
    identificadores(tipo);
  }

  static final public Simbolo.Tipo_variable tipo_variables() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tENTERO:
        jj_consume_token(tENTERO);
                 {if (true) return Simbolo.Tipo_variable.ENTERO;}
        break;
      case tBOOLEANO:
        jj_consume_token(tBOOLEANO);
                         {if (true) return Simbolo.Tipo_variable.BOOLEANO;}
        break;
      case tCARACTER:
        jj_consume_token(tCARACTER);
                   {if (true) return Simbolo.Tipo_variable.CHAR;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el tipo de las variables");
    }
    throw new Error("Missing return statement in function");
  }

//TODO: cambiar tama침o de la variable del vector por TIPO * longitud
  static final public void identificadores(Simbolo.Tipo_variable tipo) throws ParseException {
  Token id1 = null;
  Token id2 = null;
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
  Simbolo.Tipo_variable tipo_aux = null;
  RegistroExpr r = null;
  boolean esVector = false;
    try {
      id1 = jj_consume_token(tID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 58:
        jj_consume_token(58);
        r = expresion(false);
        jj_consume_token(59);
                esVector = true;
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
            try {
                        if(esVector) {
                           if(r.esVariable) {
                             //TODO: excepciones, tiene que ser una constante positiva, no una variable
                             System.out.println("Se ha detectado una varieable vector y es un identificador no cont entera");
                           }else {
                             //Caso es una constante
                             if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
                               System.out.println("Se ha detectado una varieable vector y no es constante entera");
                               //TODO: expeciones tiene que ser una constante entera
                             }else {
                                if(r.valorEnt <= 0) {
                                  System.out.println("Se ha detectado una varieable vector y no es positivo");
                                  //TODO: excepciones tiene que ser una constante positiva
                                }else {
                                  System.out.println("Se ha detectado una varieable vector llamada: " + id1.image +" y de tam: "+r.valorEnt + " y se puede declarar");
                                  //Se puede declarar el vector
                                  if(tipo == Simbolo.Tipo_variable.ENTERO) {
                                    tipo_aux = Simbolo.Tipo_variable.VECENT;
                                  }else if(tipo == Simbolo.Tipo_variable.CHAR) {
                                    tipo_aux = Simbolo.Tipo_variable.VECCHAR;
                                  }else {
                                    tipo_aux = Simbolo.Tipo_variable.VECBOOL;
                                  }
                                  s1 = tabla_simbolos.introducir_variable_vector(id1.image,tipo_aux,r.valorEnt, nivel,dir);

                                                //System.out.println("Voy a aumentar el tama침o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
                                                //TODO: cambiar get tamanyo para que devuelva longitud * tipovec
                                  dir += s1.get_tamanyo();
                                }
                             }
                           }

                        }else {
                                System.out.println("Se ha detectado una varieable normal, se procede con normalidad");
                                s1 = tabla_simbolos.introducir_variable(id1.image,tipo,nivel,dir);
                                //System.out.println("Voy a aumentar el tama침o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
                                dir += s1.get_tamanyo();
                        }
                }catch(SimboloYaDeclaradoException e2) {
                        System.out.println("Error  semantico");
                }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(60);
        id2 = jj_consume_token(tID);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 58:
          jj_consume_token(58);
          r = expresion(false);
          jj_consume_token(59);
             esVector = true;
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
            try {
              if(esVector) {
                           if(r.esVariable) {
                             //TODO: excepciones, tiene que ser una constante positiva, no una variable
                             System.out.println("Se ha detectado una varieable vector y es un identificador no cont entera");
                           }else {
                             //Caso es una constante
                             if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
                               System.out.println("Se ha detectado una varieable vector y no es constante entera");
                               //TODO: expeciones tiene que ser una constante entera
                             }else {
                                if(r.valorEnt <= 0) {
                                  System.out.println("Se ha detectado una varieable vector y no es positivo");
                                  //TODO: excepciones tiene que ser una constante positiva
                                }else {
                                  System.out.println("Se ha detectado una varieable vector y se puede declarar");
                                  //Se puede declarar el vector
                                  if(tipo == Simbolo.Tipo_variable.ENTERO) {
                                    tipo_aux = Simbolo.Tipo_variable.VECENT;
                                  }else if(tipo == Simbolo.Tipo_variable.CHAR) {
                                    tipo_aux = Simbolo.Tipo_variable.VECCHAR;
                                  }else {
                                    tipo_aux = Simbolo.Tipo_variable.VECBOOL;
                                  }
                                  s2 = tabla_simbolos.introducir_variable_vector(id2.image,tipo_aux,r.valorEnt, nivel,dir);
                                //System.out.println("Voy a aumentar el tama침o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());

                                                //TODO: cambiar get tamanyo para que devuelva longitud * tipovec
                                  dir += s2.get_tamanyo();
                                }
                             }
                           }

                        }else {
                                System.out.println("Se ha detectado una varieable normal, se procede con normalidad");
                                s1 = tabla_simbolos.introducir_variable(id2.image,tipo,nivel,dir);
                                //System.out.println("Voy a aumentar el tama침o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
                                dir += s1.get_tamanyo();
                        }
                        esVector = false;
                }catch(SimboloYaDeclaradoException e2) {
                        System.out.println("Error  semantico");
                }
      }
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el identificador");
    }
  }

  static final public void declaracion_acciones() throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tACCION:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      declaracion_accion();
    }
  }

// (cabecera_accion())";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias())
  static final public void declaracion_accion() throws ParseException {
         String etACC = et.nueva_et();
         Simbolo sim = new Simbolo();
         String s = new String();
    sim = cabecera_accion(etACC);
    jj_consume_token(tFIN_SENTENCIA);
    declaracion_variables();
    declaracion_acciones();
    bloque_sentencias(sim,etACC);
        pw.println("; Fin de la accion " + s);
        pw.println("CSF");
            //tabla_simbolos.imprimirTabla();
            //System.out.println("Voy a eliminar las variables del nivel " + nivel);
            tabla_simbolos.eliminar_variables(nivel);
            //System.out.println("Voy a eliminar acciones");
            tabla_simbolos.ocultar_parametros(nivel);
            tabla_simbolos.eliminar_acciones(nivel);
            tabla_simbolos.eliminar_parametros_ocultos(nivel+1);
            nivel--;
  }

  static final public Simbolo cabecera_accion(String etACC) throws ParseException {
    Token id_accion;
    Simbolo simbolo_accion = null;
    boolean ok;
    jj_consume_token(tACCION);
    id_accion = jj_consume_token(tID);
    try {
        //Justo despues de registrar la accion en la tabla de simbolos, incrementamos el nivel en uno.
        simbolo_accion = tabla_simbolos.introducir_accion(id_accion.image,nivel,dir,etACC/*TODO: mirar lo de las direcciones*/);

        //System.out.println("Voy a aumrntar el nivel " + (nivel +1));
        dir = INICIAL;
            nivel++;

        }catch(SimboloYaDeclaradoException e2) {
                System.out.println("Error  semantico");
        }
    parametros_formales(simbolo_accion);
    {if (true) return simbolo_accion;}
    throw new Error("Missing return statement in function");
  }

  static final public void parametros_formales(Simbolo simbolo_accion) throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 61:
        jj_consume_token(61);
        lista_parametros(simbolo_accion);
        jj_consume_token(62);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros formales");
    }
  }

  static final public void lista_parametros(Simbolo simbolo_accion) throws ParseException {
    try {
      parametros(simbolo_accion);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tFIN_SENTENCIA:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_4;
        }
        jj_consume_token(tFIN_SENTENCIA);
        parametros(simbolo_accion);
      }
    } catch (ParseException e) {
       SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de parametros");
    }
  }

  static final public void parametros(Simbolo simbolo_accion) throws ParseException {
  Simbolo.Clase_parametro clase;
  Simbolo.Tipo_variable tipo;
  Token id1;
  Token id2;
  Simbolo param;
  Simbolo param2;
  RegistroExpr r= null;
    try {
      clase = clase_parametros();
      tipo = tipo_variables();
      id1 = jj_consume_token(tID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 58:
        jj_consume_token(58);
        r = expresion(false);
        jj_consume_token(59);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
          try {
            if(r== null) {
               //System.out.println("Voy a introduxir un parametro" + simbolo_accion.getNombre() +" "+ id1.image);
                //introducimos el parametro actual en la tabla de simbolos
                param = tabla_simbolos.introducir_parametro(id1.image,tipo, clase, nivel,dir);

                //Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
                simbolo_accion.addParametro(param);
                //System.out.println("A칦췋adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
            }else{
                //Caso vector
                if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
                        //El vector esta bien definido
                        Simbolo.Tipo_variable tipo_aux = null;
                        if(tipo == Simbolo.Tipo_variable.ENTERO) {
                        tipo_aux = Simbolo.Tipo_variable.VECENT;
                        }else if(tipo == Simbolo.Tipo_variable.CHAR) {
                        tipo_aux = Simbolo.Tipo_variable.VECCHAR;
                        }else {
                        tipo_aux = Simbolo.Tipo_variable.VECBOOL;
                        }
                        param = tabla_simbolos.introducir_parametro_vector(id1.image, tipo_aux, clase, r.valorEnt, nivel, dir);
                        simbolo_accion.addParametro(param);
                }else {
                        //TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
                        System.out.println("No se puede declarar un vector sin una constante entera");
                }


            }




          }catch(SimboloYaDeclaradoException e2) {
                System.out.println("El simbolo declarado ya existe");
          }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_5;
        }
        jj_consume_token(60);
        id2 = jj_consume_token(tID);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 58:
          jj_consume_token(58);
          r = expresion(false);
          jj_consume_token(59);
          break;
        default:
          jj_la1[10] = jj_gen;
          ;
        }
          try {
            if(r == null) {
               //System.out.println("Voy a introduxir un parametro" + simbolo_accion.getNombre() +" "+ id1.image);
                //introducimos el parametro actual en la tabla de simbolos
                param2 = tabla_simbolos.introducir_parametro(id2.image,tipo, clase, nivel,dir);

                //Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
                simbolo_accion.addParametro(param2);
                //System.out.println("A칦췋adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
            }else{
                //Caso vector
                if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
                        //El vector esta bien definido
                        Simbolo.Tipo_variable tipo_aux = null;
                        if(tipo == Simbolo.Tipo_variable.ENTERO) {
                        tipo_aux = Simbolo.Tipo_variable.VECENT;
                        }else if(tipo == Simbolo.Tipo_variable.CHAR) {
                        tipo_aux = Simbolo.Tipo_variable.VECCHAR;
                        }else {
                        tipo_aux = Simbolo.Tipo_variable.VECBOOL;
                        }
                        param2 = tabla_simbolos.introducir_parametro_vector(id2.image, tipo_aux, clase, r.valorEnt, nivel, dir);
                        simbolo_accion.addParametro(param2);
                }else {
                        //TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
                        System.out.println("No se puede declarar un vector sin una constante entera");
                }


            }
          }catch(SimboloYaDeclaradoException e2) {
                System.out.println("Error  semantico");
          }
      }
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros");
    }
  }

  static final public Simbolo.Clase_parametro clase_parametros() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tVAL:
        jj_consume_token(tVAL);
                   {if (true) return Simbolo.Clase_parametro.VAL;}
        break;
      case tREF:
        jj_consume_token(tREF);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                    {if (true) return Simbolo.Clase_parametro.REF;}
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la clase de parametros");
    }
    throw new Error("Missing return statement in function");
  }

  static final public void bloque_sentencias(Simbolo s, String etACC) throws ParseException {
  //Lista necesaria para recuperar los parametros en la invicacion de la accion
  ArrayList<Simbolo> lista_param = new ArrayList<Simbolo>();
    try {
          //Generamos nueva etiqueta para el comienzo de las acciones de la accion


          //Es una accion hay una etiqueta para saber donde empiezan las intrucciones de la accion
          if(!s.ES_PROGRAMA()) {
            pw.println(";Accion " + s.getNombre());
            pw.println(etACC+":");
          }

          //Obtenemos los parametros de la accion
          lista_param = s.getListaParametros();
          //Recorremos la lista de forma inversa porque los parametros estan apilados al reves
          Simbolo p = new Simbolo();
          if(lista_param!= null) {
                  for (int j = lista_param.size() - 1; j >= 0; j--)
              {
                 p = lista_param.get(j);
                 pw.println("; rec. parametro " + p.getNombre() + " de tipo " + p.getVariable().toString() +
                 " pasado por " + p.getParametro().toString());
                 pw.println("\u005ct SRF   " + (nivel - p.getNivel()) + "  " + p.getDir());
                 pw.println("\u005ct ASGI");
              }
          }
      jj_consume_token(tPRINCIPIO);
      lista_sentencias();
      jj_consume_token(tFIN);

    } catch (ParseException e) {
//    System.out.println("1");

        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el bloque de sentencias");
    }
  }

  static final public void lista_sentencias() throws ParseException {
    sentencia();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSI:
      case tMQ:
      case tESCRIBIR:
      case tLEER:
      case tID:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      sentencia();
    }
  }

  static final public void sentencia() throws ParseException {
  Token id = null;
  boolean esVector = false;
  Simbolo simbolo_id = null;
  Simbolo s = null;
  Simbolo.Tipo_variable tpID = null;
  RegistroExpr r = null;
  boolean accesoComponente = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tLEER:
      leer();
      jj_consume_token(tFIN_SENTENCIA);
      break;
    case tESCRIBIR:
      escribir();
      jj_consume_token(tFIN_SENTENCIA);
      break;
    case tID:
      id = jj_consume_token(tID);
                simbolo_id = tabla_simbolos.buscar_simbolo(id.image);
                if(simbolo_id.ES_VARIABLE()) {
                        if(simbolo_id == null) {
                        System.out.println("Error semantico, no existe el simbolo con nombre: " + id.image +" en la tabla de simbolos");
                        tpID = Simbolo.Tipo_variable.DESCONOCIDO;
                        }
                        else if(simbolo_id.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && simbolo_id.getParametro() == Simbolo.Clase_parametro.VAL) {
                                 System.out.println("Error semantico, no se puede asignar un valor a un parametro por valor");
                                 //TODO: Mirar si esto tiene que ir aqui o en asignacion, y si se tiene que poner el tpId a desconocido para seguir la ejecucuion
                                 tpID = Simbolo.Tipo_variable.DESCONOCIDO;
                        }else {
                        tpID = simbolo_id.getVariable();
                        }

                        //MIRAR si hay que unificar if 		
                        if(simbolo_id.ES_VECTOR()) {
                        pw.println(";Inicial vector");
                        pw.println("\u0009SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
                        System.out.println("VECTOOOOOOOOOOOOOOOOOOOOOOOOOOOOOr");

                     }else {
                              pw.println("; Direccion de la variable " + simbolo_id.getNombre());
                              pw.println("\u0009SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
                         }
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 58:
        jj_consume_token(58);
        r = expresion(true);
        jj_consume_token(59);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
   //Si es el vector entero

                if(simbolo_id.ES_VARIABLE()) {
                if(r == null) {
                    //Aqui ya se empieza a asignar la primera componente
                    pw.println(";Asignacion componente 1");
                        System.out.println("Se va a asignar una variable nombre: "+ id.image + " tipo: " + simbolo_id.getVariable());
                        accesoComponente = false;
                }else{
                    accesoComponente = true;
                        System.out.println("Acceso a componente del vector aa");
                        if(r.valorEnt > simbolo_id.getLongitud()) {
                                 //TODO: excepciones, la componente solicitada esta fuera de rango
                                System.out.println("Acceso componente fuera de rango");
                        }
                        pw.println("\u0009PLUS   ");
                    }

                        esVector = true;
          }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tOPAS:
        asignacion(simbolo_id,r,tpID,accesoComponente);
        break;
      case tFIN_SENTENCIA:
      case 61:
        invocacion_accion(simbolo_id,tpID);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case tSI:
      seleccion();
      break;
    case tMQ:
      mientras_que();
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void leer() throws ParseException {
    try {
      jj_consume_token(tLEER);
           pw.println("; Lectura");
      jj_consume_token(61);
      lista_asignables();
      jj_consume_token(62);
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al leer");
    }
  }

  static final public void lista_asignables() throws ParseException {
  Token t1 = new Token();
  Token t2 = new Token();
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
    try {
      t1 = jj_consume_token(tID);
    //Obtenemos el simbolo con el nombre del id
    s1 = tabla_simbolos.buscar_simbolo(t1.image);
    if(s1 == null){
        System.out.println("El simbolo que se esta buscando no esta en la tabla");
        }else if(s1.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s1.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
                System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
        }else if(s1.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s1.getParametro() == Simbolo.Clase_parametro.VAL){
            System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
        }else if(s1.ES_VARIABLE()){
          //Obtenemos la variable
                pw.println("; Leer variable " + s1.getNombre());
        pw.println("\u005ct SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
        if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){
                pw.println("\u005ct RD    1");
                }
                else{
                        pw.println("\u005ct RD    0");
                }
        }else if(s1.ES_REFERENCIA()) {
                pw.println("; Leer parametro por referencia " + s1.getNombre());
        pw.println("\u005ct SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
        pw.println("\u005ct DRF");
        if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){
                        pw.println("\u005ct RD    1");
                }
                else{
                        pw.println("\u005ct RD    0");
                }
        }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_7;
        }
        jj_consume_token(60);
        t2 = jj_consume_token(tID);
        s2 = tabla_simbolos.buscar_simbolo(t2.image);
    if(s2 == null){
        System.out.println("El simbolo que se esta buscando no esta en la tabla");
        }else if(s2.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s2.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
                System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
        }else if(s2.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s2.getParametro() == Simbolo.Clase_parametro.VAL){
            System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
        }else if(s2.ES_VARIABLE()){
          //Obtenemos la variable
                pw.println("; Leer variable " + s2.getNombre());
        pw.println("\u005ct SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
        if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){
                        pw.println("\u005ct RD    1");
                }
                else{
                        pw.println("\u005ct RD    0");
                }
        }else if(s2.ES_REFERENCIA()) {
                pw.println("; Leer parametro por referencia " + s2.getNombre());
        pw.println("\u005ct SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
        pw.println("\u005ct DRF");
        if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){
                        pw.println("\u005ct RD    1");
                }
                else{
                        pw.println("\u005ct RD    0");
                }
        }
      }
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de asignables");
    }
  }

  static final public void escribir() throws ParseException {
    try {
      jj_consume_token(tESCRIBIR);
                pw.println("; Escritura");
      jj_consume_token(61);
      lista_escribibles();
      jj_consume_token(62);
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al escribir");
    }
  }

  static final public void lista_escribibles() throws ParseException {
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
    try {
      r1 = expresion(true);
    if(r1.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
        System.out.println("No se puede escribir un tipo desconocido");
    }else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) {
                //TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r1.tipo == Simbolo.Tipo_variable.CADENA){
        //Recorrer la cadena escribiendo letra por letra

        for (int x=1;x<r1.cadena.length()-1;x++) {
                        pw.println("\u0009STC\u0009\u0009" + (int)r1.cadena.charAt(x));
                        pw.println("\u0009WRT\u0009\u00090");
                }
        }
        else if (r1.tipo == Simbolo.Tipo_variable.ENTERO){
                pw.println("\u0009WRT\u0009\u00091");
        }else if (r1.tipo == Simbolo.Tipo_variable.CHAR){
                pw.println("\u0009WRT\u0009\u00090");
        }
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
        }
        jj_consume_token(60);
        r2 = expresion(true);
           if(r2.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
               System.out.println("No se puede escribir un tipo desconocido");
           }else if(r2.tipo == Simbolo.Tipo_variable.BOOLEANO) {
                //TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r2.tipo == Simbolo.Tipo_variable.CADENA){
        //Recorrer la cadena escribiendo letra por letra

        for (int x=1;x<r2.cadena.length()-1;x++) {
                        pw.println("\u0009STC\u0009\u0009" + (int)r2.cadena.charAt(x));
                        pw.println("\u0009WRT\u0009\u00090");
                }
        }
        else if (r2.tipo == Simbolo.Tipo_variable.ENTERO){
                pw.println("\u0009WRT\u0009\u00091");
        }else if (r2.tipo == Simbolo.Tipo_variable.CHAR){
                pw.println("\u0009WRT\u0009\u00090");
        }
      }
    } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de escribibles");
    }
  }

  static final public void invocacion_accion(Simbolo id, Simbolo.Tipo_variable tpID) throws ParseException {
  ArrayList<Simbolo > parametros_necesarios = id.getListaParametros();
  System.out.println("Se va a invocar una accion cuyos parametros son: "+ parametros_necesarios.toString());
    try {
      argumentos(id,tpID,parametros_necesarios);
      jj_consume_token(tFIN_SENTENCIA);
     pw.println("; Invocando a " + id.getNombre().toUpperCase());
     pw.println("\u005ct OSF   " + (id.getDir() - 1) + "  " + (nivel - id.getNivel())+ " " + id.getEtiqueta());
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la invocacion de acciones");
    }
  }

  static final public void asignacion(Simbolo id, RegistroExpr r, Simbolo.Tipo_variable tpID,boolean ac) throws ParseException {
  RegistroExpr r1 = new RegistroExpr();
  Simbolo.Tipo_variable tpExp;
  Token t;
  boolean accesoComponente = false;
    try {
    if(id.ES_ACCION()){
        //TODO: excepciones
        System.out.println("No se puede asignar una expresion a una accion");
    }else if(id.ES_REFERENCIA()) {
        pw.println("; Direccion del parametro por referencia " + id.getNombre());
        pw.println("\u0009SRF   " + (nivel - id.getNivel()) + "  " + id.getDir());
        pw.println("\u0009DRF");
    }else {
                //TODO: este else no se si hace falta
    }
      t = jj_consume_token(tOPAS);
      r1 = expresion(true);
            System.out.println("OPAS");
            if(r1.tipo == Simbolo.Tipo_variable.ENTERO) {
                        System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorEnt);
                }else if(r1.tipo == Simbolo.Tipo_variable.CHAR) {
                        System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorChar);
                }else if(r1.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
                        System.out.println("Se va a asignar un " + r1.tipo.toString());
                }else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) {
                        System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorBool);
                }else if(r1.tipo == Simbolo.Tipo_variable.CADENA) {
                        System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.cadena);
                }

            //Hay que mirar que los tipos sean asignables y que coincidan ambos tipos
            if(ac && r1.tipo != id.getTipoComponente()) {
                //TODO: excepcion no coincide tipo, componente del vector
                System.out.println("Acceso componente true y no coinciden tipos tipos");
                ac = false;
                }else if(ac && r1.tipo == id.getTipoComponente()) {
                        pw.println("\u0009ASG");
                //TODO: mirar si hay que hacer algoe special
                ac = false;
            }else if(id.getVariable() != r1.tipo && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                        //TODO: excepciones
                System.out.println("No se puede asignar porque los tipos no coinciden " + id.getVariable().toString()+" " + id.getNombre() + " " + r1.tipo.toString());
                }else if( r1.tipo == Simbolo.Tipo_variable.CADENA) {
                        //TODO: excepciones
                        //Caso especial las cadenas solo sirven en escribirss
                System.out.println("No se pueden asignar las cadenas, solo para escritura");
                }else if(id.ES_VECTOR()) {
                        if(id.getLongitud() != r1.tam_vec) {
                                //TODO: excepciones no coinciden en tama絪 no se puede asignar
                                System.out.println("Los vectores NO coinciden en tama\u00f1o");
                        }else {
                                System.out.println("Los vectores SI coinciden en tama\u00f1o");

                                int bytes_componente = id.get_tamanyo_componente();
                                int offset = bytes_componente;
                                pw.println("\u0009ASG");
                                for(int i = 1; i < r1.tam_vec; i++) {
                                        pw.println(";Asignacion componente "+ (i+1));
                                        pw.println("\u0009SRF   " + (nivel - id.getNivel()) + "  " + (id.getDir()+offset));
                                        pw.println("\u0009SRF   " + (nivel - r1.sim.getNivel()) + "  " + (r1.sim.getDir()+offset));
                                pw.println("\u0009DRF");
                                pw.println("\u0009ASG");
                                offset+=bytes_componente;
                                }
                        }
                }else {
                        //Si todo va bien hacemos la asignacion
                        pw.println("; Asignacion.");
                    pw.println("\u0009ASG");
                System.out.println("salgo");
          }
      jj_consume_token(tFIN_SENTENCIA);
    } catch (ParseException e) {
     SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en asignacion");
    }
  }

  static final public void mientras_que() throws ParseException {
   RegistroExpr r = new RegistroExpr();
    try {
      jj_consume_token(tMQ);
    String etMQ = et.nueva_et();
    pw.println(";MQ");
    pw.println(etMQ + ":");
      r = expresion(true);
       String etFIN = et.nueva_et();
       pw.println("\u0009JMF\u0009" + etFIN);
           if(r.tipo != Simbolo.Tipo_variable.BOOLEANO) {
                //TODO: gestionar excepciones
                System.out.println("La condicion del mientras que no es un booleano");
    }
      lista_sentencias();
      jj_consume_token(tFMQ);
     pw.println("\u0009JMP\u0009" + etMQ);
     pw.println(";FMQ");
     pw.println(etFIN + ":");
    } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en mientras que");
    }
  }

  static final public void seleccion() throws ParseException {
   RegistroExpr r = new RegistroExpr();
    try {
      jj_consume_token(tSI);
         pw.println(";SI" );
      r = expresion(true);
    String etiqSINO = et.nueva_et();
    //TODO: mirar etiqueta sino si no hay sino
    pw.println("\u0009JMF " + etiqSINO);
    if(r.tipo == Simbolo.Tipo_variable.BOOLEANO && !r.esVariable){
      //TODO mirar este if si hay que ejecutarlo
        if(r.valorBool) {
                System.out.println("Este codigo siempre se va a ejecutar porque es una constante TRUE");
        }else {
                        System.out.println("Este codigo nunca se va a ejecutar porque es una constante FALSE");
        }

    }else if(r.tipo != Simbolo.Tipo_variable.BOOLEANO ) {
                //TODO: gestionar excepciones
                System.out.println("La condicion de la seleccion no es un booleano");
    }
      jj_consume_token(tENT);
           pw.println(";ENT" );
      lista_sentencias();
    String etiqFIN= et.nueva_et();
    pw.println("\u0009JMP " + etiqFIN);
    pw.println(etiqSINO +":" );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSI_NO:
        jj_consume_token(tSI_NO);
    pw.println(";SI_NO" );
        lista_sentencias();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(tFSI);
    pw.println(etiqFIN +":" );
    pw.println(";FSI" );
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en seleccion");
    }
  }

  static final public void argumentos(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios) throws ParseException {
  ArrayList<RegistroExpr > params;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 61:
        jj_consume_token(61);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tNOT:
        case tTRUE:
        case tFALSE:
        case tENTACAR:
        case tCARAENT:
        case tMENOS:
        case tID:
        case tNUM:
        case tCAR:
        case tCADENA:
        case 61:
          params = lista_expresiones(id,tpID,parametros_necesarios);
    //TODO: pruebas con distintas funciones
        if(params.size() != parametros_necesarios.size()) {
                //TODO: gestionar excepciones 
                System.out.println("Los parametros patra invocar a la accion no coinciden "+ params.size() + " , " + parametros_necesarios.size());
        }else {
                System.out.println("Los parametros patra invocar a la accion coinciden "+ params.size() + " , " + parametros_necesarios.size());
                Simbolo s = new Simbolo();
                RegistroExpr r = new RegistroExpr();
                int num_params = params.size();
                //TODO: mirar si hay que hacer alguna comprobacion mas, por ejemplo DESCONOCIDO
                for( int i = 0; i < num_params; i++) {
                        s = parametros_necesarios.get(i);
                        r = params.get(i);
                        //System.out.println("Parametro numero " + i + " tipo_necesario: "+ s.getVariable().toString() + " tipo_pasado: " + r.tipo.toString());
                        if(s.getVariable() != r.tipo) {
                                //TODO: gestionar excepciones
                                System.out.println("Los tipos de los argumentos no coinciden");
                        }else if(s.getParametro() == Simbolo.Clase_parametro.REF && !r.esVariable) {
                                //TODO: gestionar excepciones
                                System.out.println("Se esperaba un parametro por referecncia, no por valor");
                        }
                }
        }
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
        jj_consume_token(62);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en argumentos");
    }
  }

//TODO: Hacer un programa para probar esto, devuelve una lista de RegistroExpresiones
//TODO: igual no hace falta pasar tantos parametros hasta esta funcion
  static final public ArrayList<RegistroExpr> lista_expresiones(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios) throws ParseException {
  ArrayList<RegistroExpr > params = new ArrayList<RegistroExpr>();
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
    try {
      r1 = expresion(true);
    params.add(r1);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 60:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_9;
        }
        jj_consume_token(60);
        r2 = expresion(true);
    params.add(r2);
      }
   {if (true) return params;}
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de expresiones");
    }
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_multiplicativo() throws ParseException {
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMUL:
        t = jj_consume_token(tMUL);
               {if (true) return t;}
        break;
      case tAND:
        t = jj_consume_token(tAND);
               {if (true) return t;}
        break;
      case tDIV:
        t = jj_consume_token(tDIV);
               {if (true) return t;}
        break;
      case tMOD:
        t = jj_consume_token(tMOD);
               {if (true) return t;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador multiplicativo");
    }
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_aditivo() throws ParseException {
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMAS:
        t = jj_consume_token(tMAS);
               {if (true) return t;}
        break;
      case tMENOS:
        t = jj_consume_token(tMENOS);
                 {if (true) return t;}
        break;
      case tOR:
        t = jj_consume_token(tOR);
              {if (true) return t;}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador aditivo");
    }
    throw new Error("Missing return statement in function");
  }

  static final public Token operador_relacional() throws ParseException {
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMAYOR:
        t = jj_consume_token(tMAYOR);
                 {if (true) return t;}
        break;
      case tMENOR:
        t = jj_consume_token(tMENOR);
                 {if (true) return t;}
        break;
      case tIGUAL:
        t = jj_consume_token(tIGUAL);
                 {if (true) return t;}
        break;
      case tMAI:
        t = jj_consume_token(tMAI);
               {if (true) return t;}
        break;
      case tMEI:
        t = jj_consume_token(tMEI);
               {if (true) return t;}
        break;
      case tNI:
        t = jj_consume_token(tNI);
              {if (true) return t;}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador relacional");
    }
    throw new Error("Missing return statement in function");
  }

//TODO: hacer que se pueda hacer mayor menor de caracteres, cadenas, etc??
  static final public RegistroExpr expresion(boolean vec) throws ParseException {
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
    r1 = expresion_simple(vec);
          //System.out.println("El tipo de r1 es: " + r1.tipo.toString());
          result = r1;
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tIGUAL:
      case tMAYOR:
      case tMENOR:
      case tMAI:
      case tMEI:
      case tNI:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_10;
      }
      t = operador_relacional();
      r2 = expresion_simple(vec);
          boolean ok = true;

          String operacion = t.image;
//	  if(operacion != null) { 
                  switch(operacion) {
                                case ">":
                                        pw.println("\u0009GT");
                                        //System.out.println("Detectado >");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede >");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede >");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt > r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "<":
                                        pw.println("\u0009LT");
                                        //System.out.println("Detectado <");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede <");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede <");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt < r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case ">=":
                                        pw.println("\u0009GTE");
                                        //System.out.println("Detectado >=");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede >=");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede >=");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt >= r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "<=":
                                        pw.println("\u0009LTE");
                                        //System.out.println("Detectado <=");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede <=");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede <=");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt <= r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                //TODO: mirar el < > y en = si se puede hacer con booleanos, cadenas, caracteres
                                case "=":
                                        pw.println("\u0009EQ");
                                        //System.out.println("Detectado =");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede =");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede =");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt == r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "<>":
                                        pw.println("\u0009NEQ");
                                        //System.out.println("Detectado <>");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede <>");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede <>");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorEnt != r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                  }
    }
          //System.out.println("Voy a devolver result:" + result.tipo);
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public RegistroExpr expresion_simple(boolean vec) throws ParseException {
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
    r1 = termino(vec);
          //System.out.println("primero");
      result = r1;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tOR:
      case tMAS:
      case tMENOS:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_11;
      }
      t = operador_aditivo();
      r2 = termino(vec);
          boolean ok = true;
          String operacion = t.image;
                  switch(operacion.toLowerCase()) {
                                case "+":
                                        pw.println("\u0009PLUS");
                                        //System.out.println("Detectado +");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede sumar");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede sumar");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
                                                        result.tipo =  Simbolo.Tipo_variable.ENTERO;
                                                        result.valorEnt =       result.valorEnt + r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "-":
                                        pw.println("\u0009SBT");
                                        //System.out.println("Detectado -");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede restar");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede restar");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobacionesde modulo por 0
                                                        result.tipo =  Simbolo.Tipo_variable.ENTERO;
                                                        result.valorEnt =       result.valorEnt - r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        //return result;
                                        break;
                                case "or":
                                        pw.println("\u0009OR");
                                        //System.out.println("Detectado and");
                                        if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer or");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es booleano o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer or");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorBool | r2.valorBool;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                  }
    }
          //System.out.println("Voy a devolver result:" + result.tipo);
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public RegistroExpr termino(boolean vec) throws ParseException {
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  RegistroExpr ant = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
    r1 = factor(vec);
    //System.out.println("primero");
    //Si solo es un valor devolvemos ese valor solo
    result = r1;
    ant = r1;
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tAND:
      case tMOD:
      case tMUL:
      case tDIV:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_12;
      }
      t = operador_multiplicativo();
      r2 = factor(vec);
          boolean ok = true;
          //System.out.println("segundo");
          String operacion = t.image;
                  //Hay que hacer lowercase porque aunque el analizador sea case insensitive, el switch reconoce la diferencia entre mayusculas y minusculas
                  switch(operacion.toLowerCase()) {
                                case "*":
                                        pw.println("\u0009TMS");
                                        //System.out.println("Detectado *");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede multiplicar");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede multiplicar");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                    System.out.println("Voy a multiplicar: " + result.valorEnt + " y " + r2.valorEnt);
                                                        result.tipo =  Simbolo.Tipo_variable.ENTERO;
                                                        result.valorEnt =       result.valorEnt * r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt * r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "mod":
                                        pw.println("\u0009MOD");
                                        //System.out.println("Detectado mod");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede hacer mod");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede hacer mod");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                          //Mirar si esto va bien
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                    if(!r2.esVariable) {
                                                        System.out.println("Voy a mod de constante: " + result.valorEnt + " y " + r2.valorEnt);
                                                        if(r2.valorEnt == 0) {
                                                                //TODO: Gestionar excepciones de modulo 0
                                                                System.out.println("Es modeulo 0");
                                                        }else {
                                                                result.valorEnt =       result.valorEnt % r2.valorEnt;
                                                        }
                                                        }else {
                                                                //TODO: Mirar que hay que hacer aqui
//		  					    System.out.println("regexpr "+r2.esVariable);
//		  					  	result.tipo =  Simbolo.Tipo_variable.ENTERO;
//		  						result.valorEnt =	result.valorEnt % r2.valorEnt;
                                                        }

                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "div":
                                        pw.println("\u0009DIV");
                                        System.out.println("Detectado /");
                                        if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es entero por lo tanto no se puede dividir");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es entero por lo tanto no se puede dividir");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                  //TODO: hay que hacer las comprobaciones de division por 0
                                                        System.out.println("Voy a dividir: " + result.valorEnt + " y " + r2.valorEnt);
                                                        result.tipo =  Simbolo.Tipo_variable.ENTERO;
                                                        result.valorEnt =       result.valorEnt / r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt / r2.valorEnt;
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;
                                case "and":
                                        pw.println("\u0009AND");
                                        //System.out.println("Detectado and");
                                        if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer and");
                                                ok = false;
                                        }
                                        if(ok){ //El primer parametro es entero o desconocido
                                                if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer and");
                                                        ok = false;
                                                }
                                        }
                                        if(ok) {
                                                if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                                                        System.out.println("Voy a and: " + result.valorBool + " y " + r2.valorBool);
                                                        result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
                                                        result.valorBool =      result.valorBool && r2.valorBool;
                                                        System.out.println("salgo de and");
//		  					ant.valorBool = r1.valorBool && r2.valorBool; 
                                                }else {
                                                        result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
                                                }
                                        }
                                        break;

                  }
    }
    //System.out.println("Voy a devolver result:" + result.tipo);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/*("-" factor()
	| <tNOT> factor()
	| "(" expresion() ")"
	| <tENTACAR> "(" expresion() ")"
	| <tCARAENT> "(" expresion() ")"
	| <tID>
	| <tNUM>
	| <tCAR>
	| <tCADENA>
	| <tTRUE>| <tFALSE>)*/
  static final public RegistroExpr factor(boolean vec) throws ParseException {
  RegistroExpr re = null;
  Token t;
  Simbolo s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMENOS:
      jj_consume_token(tMENOS);
      re = factor(vec);
    pw.println("\u0009NGBI");
    if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                        System.out.println("El tipo de la variable no es compatible con \u005c"-\u005c" ");
                        //TODO: mirar si hay que lanzar una excepcion o hacer algo mas
                        //Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.ENTERO) {
                re.valorEnt = -re.valorEnt;
                {if (true) return re;}
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      {if (true) return re;}
    }
      break;
    case tNOT:
      jj_consume_token(tNOT);
      re = factor(vec);
    pw.println("\u0009NGB");
    if(re.tipo != Simbolo.Tipo_variable.BOOLEANO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                        System.out.println("El tipo de la variable no es compatible con \u005c"NOT\u005c" ");
                        //TODO: mirar si hay que lanzar una excepcion o hacer algo mas
                        //Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.BOOLEANO) {
                re.valorBool = !re.valorBool;
                {if (true) return re;}
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      {if (true) return re;}
    }
      break;
    case 61:
      jj_consume_token(61);
      re = expresion(true);
      jj_consume_token(62);
    //Si solo hay parentesis hay que devolver lo que hay dentro de los parentesis
    {if (true) return re;}
      break;
    case tENTACAR:
      t = jj_consume_token(tENTACAR);
      jj_consume_token(61);
      re = expresion(true);
      jj_consume_token(62);
        if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
        //Si no sabemos el tipo propagamos lo que nos han pasado
                {if (true) return re;}
    }else {
        RegistroExpr new_r = new  RegistroExpr();
        new_r.tipo= Simbolo.Tipo_variable.CHAR;
                new_r.valorChar = (char)re.valorEnt;
                {if (true) return new_r;}
    }
      break;
    case tCARAENT:
      jj_consume_token(tCARAENT);
      jj_consume_token(61);
      re = expresion(true);
      jj_consume_token(62);
    if(re.tipo != Simbolo.Tipo_variable.CHAR && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
                System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
        //Si no sabemos el tipo propagamos lo que nos han pasado
                {if (true) return re;}
    }else {
        RegistroExpr new_r = new  RegistroExpr();
        new_r.tipo= Simbolo.Tipo_variable.ENTERO;
                new_r.valorEnt = (int)re.valorChar;
                {if (true) return new_r;}
    }
      break;
    case tID:
      t = jj_consume_token(tID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 58:
        jj_consume_token(58);
        re = expresion(false);
        jj_consume_token(59);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
     System.out.println("He encontrado un id");
     s = tabla_simbolos.buscar_simbolo(t.image);
     if(s == null) {
         System.out.println("No he encontrado simbolo");
        //TODO: no existe el simbolo hay que lanzar una exepcion
     }else if(s.ES_ACCION()) {
        System.out.println("He encontrado una accion");
        //TODO: no existe el simbolo hay que lanzar una exepcion
     }else if(s.ES_VECTOR()) {
        System.out.println("He encontrado un vector");
        if(re != null) {
                System.out.println("eteteyyeyeyeyyeye");
                //Es una componente del vector
                if(re.esVariable) {
                                //otras cosas
                        }else {
                        //Caso es una constante
                        if(re.tipo != Simbolo.Tipo_variable.ENTERO) {
                                System.out.println("Se ha detectado una varieable vector y no es constante entera");
                                //TODO: expeciones tiene que ser una constante entera
                        }else {
                                if(re.valorEnt <= 0) {
                                        System.out.println("Se ha detectado una varieable vector y no es positivo");
                                        //TODO: excepciones tiene que ser una constante positiva
                                }else if(re.valorEnt > s.getLongitud()){
                                  System.out.println("Overflow vectores");
                                        //TODO: Overflow indexacion

                                }else {
                                        System.out.println("aaSe ha detectado una varieable vector llamada: " + t.image +" y de tam: "+re.valorEnt + " y se puede declarar");
                                        //Se puede declarar el vector
                                        Simbolo.Tipo_variable tipo_aux = s.getTipoComponente();
                                        re.tipo = tipo_aux;
                                            re.s = s.getTipo();
                                            re.esVariable = true;
                                            re.sim = s;
                                        pw.println("; Acceso a la variable " + s.getNombre() + "[" + re.valorEnt+ "]");
                                        pw.println("\u0009SRF\u0009"+  (nivel - s.getNivel()) + "\u0009" + s.calcularDesplazamientoDireccion(re.valorEnt -1));
                                        pw.println("\u0009DRF");

                                            {if (true) return re;}
                                }
                        }
                }
        }else {
                System.out.println("He encontrado un id normal");
                re = new  RegistroExpr();
                        re.tipo = s.getVariable();
                //Es un vector entero
                re.tam_vec = s.getLongitud();
                re.s = s.getTipo();
                    re.esVariable = true;
                    re.sim = s;
                    pw.println("; Acceso a la variable " + s.getNombre());
                pw.println("\u0009SRF\u0009"+  (nivel - s.getNivel()) + "\u0009" + s.getDir());
                pw.println("\u0009DRF");
                    {if (true) return re;}
        }
     }else {
         re = new  RegistroExpr();
             pw.println("; Acceso a la variable " + s.getNombre());
         pw.println("\u0009SRF\u0009"+  (nivel - s.getNivel()) + "\u0009" + s.getDir());
         pw.println("\u0009DRF");
             re.tipo = s.getVariable();
             re.s = s.getTipo();
             re.esVariable = true;
             re.sim = s;
             {if (true) return re;}
        }
      break;
    case tNUM:
      t = jj_consume_token(tNUM);
     if(vec)pw.println("\u0009STC   " + t.image);
     System.out.println("Hay una const entera");

     {if (true) return RegistroExpr.ENTERO(t.image);}
      break;
    case tCAR:
      t = jj_consume_token(tCAR);
     pw.println("\u0009STC   " + t.image);
     {if (true) return RegistroExpr.CHAR(t.image);}
      break;
    case tCADENA:
      t = jj_consume_token(tCADENA);
     pw.println(";cadena\u0009" + t.image);
     {if (true) return RegistroExpr.CADENA(t.image);}
      break;
    case tTRUE:
      jj_consume_token(tTRUE);
     pw.println("\u0009STC   1" );
     {if (true) return RegistroExpr.BOOL(true);}
      break;
    case tFALSE:
      t = jj_consume_token(tFALSE);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     pw.println("\u0009STC   0" );
     {if (true) return RegistroExpr.BOOL(false);}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public MiniLengCompilerTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6880000,0x0,0x0,0x6880000,0x0,0x0,0x200000,0xf0010000,0x0,0x0,0x8004000,0x8000,0x0,0x0,0x8000,0x8004000,0x0,0xf0010000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x38,0x38,0x4000000,0x10000000,0x4000000,0x1,0x20000000,0x80,0x4000000,0x10000000,0x4000000,0x6,0x40000,0x4000000,0x20002080,0x40000,0x10000000,0x10000000,0x0,0x20760000,0x20000000,0x10000000,0xc000,0x30000,0x1f40,0x1f40,0x30000,0xc000,0x4000000,0x20760000,};
   }

  /** Constructor with InputStream. */
  public MiniLengCompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MiniLengCompiler(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MiniLengCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MiniLengCompiler(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MiniLengCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MiniLengCompiler(MiniLengCompilerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MiniLengCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[63];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 63; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
