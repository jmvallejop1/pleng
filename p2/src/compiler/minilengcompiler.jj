/**
 * EspecificaciÃƒÆ’Ã‚Â³n JavaCC para la PrÃƒÆ’Ã‚Â¡ctica 2 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.2 - 2021/03/08
 */

//TODO IMPORTNTE: comprobacion overflow lado derecho asignacion
//fib no va
options
{
  static = true;
  //hacemos el leguaje case insenstive, ignoramos la diferencia entre mayusculas y minusculas.
  ignore_case = true;
}

PARSER_BEGIN(MiniLengCompiler)
package compiler;
import java.io.*;
import semantico.*;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.PrintWriter;


public class MiniLengCompiler
{


  public static class RegistroExpr {
	int valorEnt;
	boolean valorBool;
	char valorChar;
	boolean esVariable = false;
	String cadena;
	Simbolo.Tipo_variable tipo;
	Simbolo.Tipo_simbolo s;
	int tam_vec = -1;
	Simbolo sim = null;
	boolean componente = false;
	boolean valor_hecho = false;

	//Devuelve un Registro expresion booleano 
	public static RegistroExpr BOOL(boolean b) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.BOOLEANO;
		reg.valorBool = b;
		reg.esVariable = false;
		return reg;
	}
	//Devuelve un Registro de tipo Entero
	public static RegistroExpr ENTERO(String entero) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.ENTERO;
		reg.valorEnt = Integer.parseInt(entero);
		reg.esVariable = false;
		return reg;
	}
	//Devuelve un Registro de tipo Char
	public static RegistroExpr CHAR(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CHAR;
		reg.valorChar = c.charAt(1);
		reg.esVariable = false;
		return reg;
	}
	
	//Devuelve un Registro de tipo cadena
	public static RegistroExpr CADENA(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CADENA;
		reg.cadena = c;
		reg.esVariable = false;
		return reg;
	}
	}

  public static Etiqueta et = new Etiqueta();
  //Declaracion print writer para escribir el fichero .code
  public static PrintWriter pw;
	
  //Declaraciones necesarias para tablla de simbolos
  static int nivel = 0;
  static final int INICIAL = 3;

  //Inicializacion de la direccion para aÃƒÂ¯Ã‚Â¿Ã‚Â½adir a la tabla de simbolos
  
  public static int dir = INICIAL;
  public static int dir0 = INICIAL;
  public static int dir_a = INICIAL;
  
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  public static void main(String args []) throws ParseException
  {
    //Pasamos como parametro el fichero que queremos compilar
    //Intentamos leer el fichero 
    try {
      	  String dir ="C:\\Users\\Jmval\\OneDrive\\Escritorio\\pleng\\p2\\programas\\programas\\"+args[0] +".ml";
      	  //String dir ="/Users/lauraomist/Desktop/pleng/p2/programas/programas/"+args[0] +".ml";
      	  System.out.println(dir);
	      FileInputStream F = new FileInputStream(dir);
	      System.setIn(F);
	}catch (Exception e) {
	   //Si no encuentra fichero lee de la entrada estandar
	    System.out.println("Leyendo de la entrada estandar...");
    }
    
   
	 try {
	   		 //TODO: cambiar esto por el nombre del fichero + code
			File cod_inter = new File("C:\\Users\\Jmval\\OneDrive\\Escritorio\\pleng\\p2\\codigo_intermedio\\"+args[0]+".code");
	   		 //File cod_inter = new File("/Users/lauraomist/Desktop/pleng/p2/codigo_intermedio/"+args[0]+".code");
    		 FileWriter fichero_salida = new FileWriter(cod_inter);
   			 pw = new PrintWriter(fichero_salida);
	         MiniLengCompiler parser = new MiniLengCompiler(System.in);
	   		 tabla_simbolos.inicializar_tabla();
	   		 MiniLengCompiler.programa();
	  }catch (TokenMgrError e) {
	      try {
	           //gestion de los errores lexicos
		       int linea = SimpleCharStream.getBeginLine();
		       int columna = SimpleCharStream.getBeginColumn();
		       char c = SimpleCharStream.readChar();
	           LexicalErrorManager.printLexicalError(linea,columna,c);
	      }catch(Exception ex){}  
		}
		//TODO:gestionar excepcion del print writer
		catch (IOException e) { }
 	 }
}

PARSER_END(MiniLengCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMENTARIO
| "%%": COMENTARIO_MULTILINEA
}

< COMENTARIO_MULTILINEA> SKIP:
{
  "%%": DEFAULT
  | < ~[] >  
}


< COMENTARIO >SKIP: {
	"\n":DEFAULT
	| < ~[] >  
}



TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
| < tMETODO : "metodo" >
 | < tPROGRAMA : "programa" >
| < tAND : "and" >
| < tOR : "or" >
| < tNOT : "not" >
| < tPRINCIPIO : "principio" >
| < tFIN : "fin" >
| < tSI : "si" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tFSI : "fsi" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >
| < tMOD : "mod" >
| < tTRUE : "true" >
| < tFALSE : "false" >
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
| < tACCION : "accion" >
| < tVAL : "val" >
| < tREF : "ref" >

}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
}



TOKEN : /* OPERADORES */
{
  <  tIGUAL : "=" >
| <  tFIN_SENTENCIA : ";" >
| <  tMAYOR : ">" >
| <  tMENOR : "<" >
| <  tMAI : ">=" >
| <  tMEI : "<=" >
| <  tNI : "<>" >
| <  tOPAS : ":=" >
| <  tMUL : "*" >
| <  tDIV : "div" >
| <  tMAS : "+" >
| <  tMENOS : "-" >
}

TOKEN : /* VALORES */
{
< tID : ((( < tLetra > | "_" )(<tLetra> | "_" | <tCifra>)* (<tLetra> | <tCifra>))) | < tLetra > >
| < tNUM : (<tCifra>)+ >
| <  tCAR : "\"" (<tLetra> | <tCifra> | <tSigno> | " " | "." | "," | ";" | "*" | ":" | "(" | ")" | "/" | "?"| "ÃƒÂ¯Ã‚Â¿Ã‚Â½") "\"" >
| <  tCADENA : "\"" (<tLetra> |<tCifra>|<tSigno>| " "|"."|","|";"|"*"|":"|"("|")"|"/"|"?")+  "\"" >
| <  tCifra : ["0"-"9"] >
| <  tLetra: ["a"-"z"] >
| <tSigno: "+" | "-" >
}

/*ANALIZADOR SINTACTICO*/

void programa():
{
  Token programa;
}
{
 try {
	 <tPROGRAMA> programa = <tID>
	 {
	  Simbolo p = new Simbolo();
	  p = tabla_simbolos.introducir_programa(programa.image,dir);
	  dir++;
	  
	  pw.println("; Programa " + programa.image + ".");
	  //Introducimos la primera intruccion de inicio de programa
	  String et_p = et.nueva_et();
	  pw.println("	ENP  " + et_p);
	  
	  //tabla_simbolos.imprimirTabla();
	 }";" 
	 declaracion_variables()
	 {
	   pw.println("; Comienzo del programa " + programa.image);
	 }
	 declaracion_acciones()
	 {
	   pw.println(et_p + ":");
	 }
	 bloque_sentencias(p, et_p)
	 {
		pw.println("; Fin del programa " + programa.image);
      	pw.println("LVP");
	 }
	 {
	   pw.close();
	 }
 }catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la creacion del programa");
  }
}



void declaracion_variables():
{
}
{ try {
    (declaracion()";")*
  } catch (ParseException e) {
          SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la declaracion de variables");
    }
}

void declaracion():
{
  Simbolo.Tipo_variable tipo;
}
{ 
  tipo = tipo_variables() (identificadores(tipo))
}

Simbolo.Tipo_variable tipo_variables():
{
}
{ try {
  < tENTERO >	{return Simbolo.Tipo_variable.ENTERO;}
  | < tBOOLEANO >	{return Simbolo.Tipo_variable.BOOLEANO;}
  | < tCARACTER > {return Simbolo.Tipo_variable.CHAR;}
} catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el tipo de las variables");
  }
}


void identificadores(Simbolo.Tipo_variable tipo):
{
  Token id1 = null;
  Token id2 = null;
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
  Simbolo.Tipo_variable tipo_aux = null;
  RegistroExpr r = null;
  boolean esVector = false;
}
{
  try {
  	 (
  	   id1 = < tID >
  	   {
  	     r = null;
  	     esVector = false;
  	   }
  	   ("[" r = expresion(true,false,null)"]"
  	   {
  	     	
  	    	esVector = true;
  	    	
  	   })?)
	  {
	    try {
	 		if(esVector) {
	 		   if(r.esVariable) {
	 		     System.out.println("Error semantico: Definicion de vector sin constante entera - linea "+id1.beginLine + " columna " + id1.beginColumn);
	 		   }else {
	 		     //Caso es una constante
	 		     if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
	 		       System.out.println("Error semantico: Definicion de vector sin constante entera - linea "+id1.beginLine + " columna " + id1.beginColumn);
	 		     }else {
	 		        if(r.valorEnt <= 0) {
	 		          System.out.println("Error semantico: Definicion de vector con constante negativa o 0 - linea "+id1.beginLine + " columna " + id1.beginColumn);
	 		        }else {
	 		          if(tipo == Simbolo.Tipo_variable.ENTERO) {
			            tipo_aux = Simbolo.Tipo_variable.VECENT;
			          }else if(tipo == Simbolo.Tipo_variable.CHAR) {
			            tipo_aux = Simbolo.Tipo_variable.VECCHAR;
			          }else {
			            tipo_aux = Simbolo.Tipo_variable.VECBOOL;
			          }
	 		          s1 = tabla_simbolos.introducir_variable_vector(id1.image,tipo_aux,r.valorEnt, nivel,dir);
	 		          dir += s1.get_tamanyo();
	 		        }
	 		     }
	 		   }
	 		}else {
	 		  	s1 = tabla_simbolos.introducir_variable(id1.image,tipo,nivel,dir);
				dir += s1.get_tamanyo();
	 		} 	
	  	}catch(SimboloYaDeclaradoException e2) {
//	  	  	System.out.println("Error  semantico: identificador duplicado: " + id1.image + ". En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	  	}
	  }
	("," (id2 = < tID >
	 {
  	     r = null;
  	     esVector = false;
  	   }
	("[" r = expresion(true,false,null)"]"
	{
  	     esVector = true;
  	}
  	)?)
  	{
	    try {
	      if(esVector) {
	 		   if(r.esVariable) {
	 		     //TODO: excepciones, tiene que ser una constante positiva, no una variable
	 		     System.out.println("Error semantico: Definicion de vector sin constante entera - linea "+id2.beginLine + " columna " + id2.beginColumn);
	 		   }else {
	 		     //Caso es una constante
	 		     if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
	 		       System.out.println("Error semantico: Definicion de vector sin constante entera - linea "+id2.beginLine + " columna " + id2.beginColumn);
	 		       //TODO: expeciones tiene que ser una constante entera
	 		     }else {
	 		        if(r.valorEnt <= 0) {
	 		           System.out.println("Error semantico: Definicion de vector con constante negativa o 0 - linea "+id1.beginLine + " columna " + id1.beginColumn);
	 		        }else {
	 		          if(tipo == Simbolo.Tipo_variable.ENTERO) {
			            tipo_aux = Simbolo.Tipo_variable.VECENT;
			          }else if(tipo == Simbolo.Tipo_variable.CHAR) {
			            tipo_aux = Simbolo.Tipo_variable.VECCHAR;
			          }else {
			            tipo_aux = Simbolo.Tipo_variable.VECBOOL;
			          }
	 		          s2 = tabla_simbolos.introducir_variable_vector(id2.image,tipo_aux,r.valorEnt, nivel,dir);
	 		          dir += s2.get_tamanyo();
	 		        }
	 		     }
	 		   }
	 		}else {
	 		  	s2 = tabla_simbolos.introducir_variable(id2.image,tipo,nivel,dir);
				dir += s2.get_tamanyo();
	 		}
	 		esVector = false;
	  	}catch(SimboloYaDeclaradoException e2) {
	  	  	System.out.println("Error  semantico");
	  	}
	  }
  	)*
  
  } catch (ParseException e) {
    //TODO:Mejorar esto 
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el identificador");
  }
}

void declaracion_acciones():
{
}
{
  (declaracion_accion())*
}

// (cabecera_accion())";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias())
void declaracion_accion():
{
  	 String etACC = et.nueva_et();
	 Simbolo sim = new Simbolo();
	 String s = new String();
}
{
  (sim = cabecera_accion(etACC))";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias(sim,etACC))
  {

    	dir = sim.getDir();
    	pw.println("; Fin de la accion " + s);
     	pw.println("CSF");
	    tabla_simbolos.eliminar_variables(nivel);
	    tabla_simbolos.ocultar_parametros(nivel);
	    tabla_simbolos.eliminar_acciones(nivel);
	    tabla_simbolos.eliminar_parametros_ocultos(nivel+1);
	    nivel--;
		dir++;
  }
}

Simbolo cabecera_accion(String etACC):
{
    Token id_accion;
    Simbolo simbolo_accion = null;
    boolean ok;
}
{
  ((<tACCION> id_accion = <tID>
  {
    try {
      	//Justo despues de registrar la accion en la tabla de simbolos, incrementamos el nivel en uno.
      	simbolo_accion = tabla_simbolos.introducir_accion(id_accion.image,nivel,dir,etACC);
      	
      	dir = INICIAL;
	    nivel++;
	   
	}catch(SimboloYaDeclaradoException e2) {
	  	//TODO: aqui ninca llega salta antes la excepcion
	  	//System.out.println("Error  semantico: Identificador duplicado: " + id_accion.image() + " En la linea " + id_accion.beginLine + " y la columna " + id_accion.beginColumn);
	}
  }
  //le pasamos a los parametros formales el simbolo de la accion a la que pertenecen para asi poder relacionarlos.
  ) parametros_formales(simbolo_accion))
  {
    return simbolo_accion;
  }
}

void parametros_formales(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos pasando el simbolo de la accion para poder asiciarla con los parametros
	("("(lista_parametros(simbolo_accion))")")?
  } catch (ParseException e) {   
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros formales");
  }
}

void lista_parametros(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos propagando el simbolo de la accion para poder asociarla
	parametros(simbolo_accion)(";"parametros(simbolo_accion))*
  } catch (ParseException e) {
       SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de parametros");
  }
}


void parametros(Simbolo simbolo_accion):
{
  Simbolo.Clase_parametro clase;
  Simbolo.Tipo_variable tipo;
  Token id1;
  Token id2;
  Simbolo param;
  Simbolo param2;
  RegistroExpr r= null;
}
{ try {
  	//Obtenemos la clase y el timpod el parametro que queremos introducir
	(clase = clase_parametros() tipo = tipo_variables()  id1 = < tID > ("[" r = expresion(false, false,null) "]")?
	{
	  try {
	    if(r== null) {
	    	//introducimos el parametro actual en la tabla de simbolos
	    	param = tabla_simbolos.introducir_parametro(id1.image,tipo, clase, nivel,dir);
			dir+=1;//param.get_tamanyo();
	    	//Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
	    	simbolo_accion.addParametro(param);
	    }else{
	      	
	      	//Caso vector
	      	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
	      	  	Simbolo.Tipo_variable tipo_aux = null;
	      	  	if(tipo == Simbolo.Tipo_variable.ENTERO) {
	            	tipo_aux = Simbolo.Tipo_variable.VECENT;
	            	
	          	}else if(tipo == Simbolo.Tipo_variable.CHAR) {
	            	tipo_aux = Simbolo.Tipo_variable.VECCHAR;
	          	}else {
	            	tipo_aux = Simbolo.Tipo_variable.VECBOOL;
	          	}
	          	if(clase == Simbolo.Clase_parametro.REF) { 
	      	  		param = tabla_simbolos.introducir_parametro_vector(id1.image, tipo_aux, clase, r.valorEnt, nivel, dir);
		      	  	dir +=  1;//param.get_tamanyo();
		      	  	simbolo_accion.addParametro(param);
		      	}else {
		      	  //TODO: excepciones no se puede pasar un vector entero como parametro por valor
		      	  System.out.println("No se pueden pasar vectores por enteros por valor");
//		      	  //vector pasado por valor
//		      	   	param = tabla_simbolos.introducir_parametro_vector(id1.image, tipo, clase, r.valorEnt, nivel, dir);
//		      	  	dir +=  a;
//		//	      	  	System.out.println("He introducido el vector a la lista de params");
//					
//		      	  	simbolo_accion.addParametro(param);
//		      	  int aux = 2;
//		      	  for(int i = 1; i < r.valorEnt;i++) {
//		      	    param = tabla_simbolos.introducir_parametro_vector(id1.image+aux, tipo, clase, r.valorEnt, nivel, dir);
//		      	  	dir +=  a;
//		      	  	aux++;
//					
//	//	      	  	System.out.println("He introducido el vector a la lista de params");
//		      	  	simbolo_accion.addParametro(param);
//		      	  }

		      	}	
	      	}else {
	      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
	      	  	//System.out.println("Errpr semantico: No se puede declarar un vector sin una constante entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	      	}
	      	
	      	 
	    }
	   
	    
	    
	    
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("El simbolo declarado ya existe");
	  }
	}



	(","id2 = < tID > ("[" r = expresion(false,false,null) "]")?
	{
	  try {
	    if(r == null) {
	    	//introducimos el parametro actual en la tabla de simbolos
	    	param2 = tabla_simbolos.introducir_parametro(id2.image,tipo, clase, nivel,dir);
			dir+= 1;//param2.get_tamanyo();
	    	//Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
	    	simbolo_accion.addParametro(param2);
	    	//System.out.println("AÃƒÂ¯Ã‚Â¿Ã‚Â½adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
	    }else{
	      	//Caso vector
	      	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
	      	  	//El vector esta bien definido
	      	  	Simbolo.Tipo_variable tipo_aux = null;
	      	  	if(tipo == Simbolo.Tipo_variable.ENTERO) {
	            	tipo_aux = Simbolo.Tipo_variable.VECENT;
	          	}else if(tipo == Simbolo.Tipo_variable.CHAR) {
	            	tipo_aux = Simbolo.Tipo_variable.VECCHAR;
	          	}else {
	            	tipo_aux = Simbolo.Tipo_variable.VECBOOL;
	          	}

	     		if(clase == Simbolo.Clase_parametro.REF) { 
	      	  		param2 = tabla_simbolos.introducir_parametro_vector(id2.image, tipo_aux, clase, r.valorEnt, nivel, dir);
	      	  		dir+= 1;param2.get_tamanyo();
	      	  		simbolo_accion.addParametro(param2);
		      	}else {
		      	  //TODO: excepciones no se puede pasar un vector entero como parametro por valor
		      	  System.out.println("No se pueden pasar vectores por enteros por valor");
		     	}
	      	  	
	      	}else {
	      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
	      	  	//System.out.println("Error semantico: No se puede declarar un vector sin una constante entera. En la linea " + id2.beginLine + " y la columna " + id2.beginColumn);
	      	}
	      	
	      	 
	    }
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("Error  semantico");
	  }
	}
	)*)
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros");
  }
}

Simbolo.Clase_parametro clase_parametros():
{
}
{ try {
	(< tVAL > {return Simbolo.Clase_parametro.VAL; }
	| < tREF >){return Simbolo.Clase_parametro.REF; }
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la clase de parametros");
  }
}

void bloque_sentencias(Simbolo s, String etACC):
{
  //Lista necesaria para recuperar los parametros en la invicacion de la accion
  ArrayList<Simbolo> lista_param = new ArrayList<Simbolo>();
}
{ try {
  	{
  	  
	  //Es una accion hay una etiqueta para saber donde empiezan las intrucciones de la accion
	  //Obtenemos los parametros de la accion
  	  lista_param = s.getListaParametros();
  	  //Recorremos la lista de forma inversa porque los parametros estan apilados al reves
  	  Simbolo p = new Simbolo();
  	   if(!s.ES_PROGRAMA()) {
	    pw.println("\t JMP	" + etACC);
  	    pw.println(";Accion " + s.getNombre());
  	    pw.println(etACC+":");
  	  }
  	  if(lista_param!= null) { 
	  	  for (int j = lista_param.size() - 1; j >= 0; j--)
	      {
	         p = lista_param.get(j);
	         pw.println("; rec. parametro " + p.getNombre() + " de tipo " + p.getVariable().toString() + 
	         " pasado por " + p.getParametro().toString());
	         pw.println("\t SRF   " + (nivel - p.getNivel()) + "  " + p.getDir());
	         pw.println("\t ASGI");
	      }
	  }
	 
	 

  	}
	(< tPRINCIPIO > lista_sentencias() < tFIN >)
  } catch (ParseException e) {
    
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el bloque de sentencias");
  }
}
void lista_sentencias():
{
}
{ 
	sentencia()(sentencia())*
}

void sentencia():
{
  Token id = null;
  boolean esVector = false;
  Simbolo simbolo_id = null;
  Simbolo s = null;
  Simbolo.Tipo_variable tpID = null;
  RegistroExpr r = null;
  boolean accesoComponente = false;
}
{
 (leer() ";"
 | escribir() ";"
 | (id = < tID >
 {
   		pw.println(";Acceso a variable " + id.image);
 		simbolo_id = tabla_simbolos.buscar_simbolo(id.image);
 		if(simbolo_id == null){
			//TODO: excepciones no eciste el simbolo
 		}else if(simbolo_id.ES_VARIABLE() || simbolo_id.ES_PARAMETRO()) {
		  	if(simbolo_id.ES_VALOR()) {
		  	  	 System.out.println("Error semantico: No se puede asignar un parametro por valor - linea "+id.beginLine + " columna " + id.beginColumn);
				//TODO: Mirar si esto tiene que ir aqui o en asignacion, y si se tiene que poner el tpId a desconocido para seguir la ejecucuion
		   	}else if(simbolo_id.ES_REFERENCIA()) {
		   	  	//Si es un parametro por referencia hay que hacer un drf porque con el srf se obtiene la direccion
		   	  	System.out.println("Referencia");
				pw.println("	SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
				pw.println("	DRF");
				pw.println(";	comprobamos si esta inicializada la variable " + simbolo_id.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
		   	}else if(simbolo_id.ES_VECTOR()) {
		        pw.println(";Inicial vector");
		        pw.println("	SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
		     }else {
		        //Es una variable normal, solo hay que hacer srf
			 	pw.println("; Direccion de la variable " + simbolo_id.getNombre());
			 	pw.println("	SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
			 	//valor centinela
//			 	pw.println(";Inicializamos con valor centinela la variable " + simbolo_id.getNombre());
//			 	pw.println("	STC   " + "77777");
//			 	pw.println("	ASG");
			 }
		}	
	
	  		
   
 }
 ("["r = expresion(false,false,simbolo_id)"]")?
 {
   //Si es el vector entero
		
   		if(simbolo_id.ES_VARIABLE() || simbolo_id.ES_PARAMETRO()) { 
	        if(r == null) {
	            //Aqui ya se empieza a asignar la primera componente
	            //pw.println(";Asignacion componente 1");
//	          	System.out.println("Se va a asignar una variable nombre: "+ id.image + " tipo: " + simbolo_id.getVariable());
	          	accesoComponente = false;
	        }else{
	            accesoComponente = true;
	    	  	if(r.valorEnt > simbolo_id.getLongitud() || r.valorEnt < 1) {
 					System.out.println("Error semantico: Acceso componente fuera de rango - linea "+id.beginLine + " columna " + id.beginColumn);
	    		}
	    		//Como se empieza por la componente 1 hay que restar lo que ocupe el primer elemanto
	    		pw.println("	STC	" + simbolo_id.get_tamanyo_componente());
	    		pw.println("	TMS	");
	    		pw.println("	STC	" + simbolo_id.get_tamanyo_componente());
	    		pw.println("	SBT		");	
	    		pw.println("	PLUS		");	
		    }
	
	   		esVector = true;
	  }
 }
 )(asignacion(simbolo_id,r,id,accesoComponente)|invocacion_accion(simbolo_id,id))
 |seleccion ()
 | mientras_que())
}

void leer():
{
}
{ try {
  <tLEER> {pw.println("; Lectura"); }
  "(" lista_asignables() ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al leer");
  }
}


void lista_asignables():
{
  Token t1 = new Token();
  Token t2 = new Token();
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
  boolean esComponente = false;
  RegistroExpr r = null;
  boolean esvector= false;
}
{ try {
  t1 = <tID>
  {
    esComponente = false;
    r = null;//Obtenemos el simbolo con el nombre del id
//    System.out.println("AccesoComponente en lista asiganbles: " + esComponente);
    s1 = tabla_simbolos.buscar_simbolo(t1.image);
    if(s1 == null){
      	//TODO: excepciones
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(!s1.ES_PARAMETRO() &&  !s1.ES_VARIABLE()){
  	    System.out.println("Error semantico: El simbolo no es asignable - linea "+t1.beginLine + " columna " + t1.beginColumn);
  	}else if(s1.ES_VALOR()){
  	  System.out.println("Error semantico: El simbolo no es asignable (PARAMETRO POR VALOR) - linea "+t1.beginLine + " columna " + t1.beginColumn);
  	}else if(s1.ES_VECTOR()) {
  	  	esvector = true;
	    pw.println("; Leer variable vector " + s1.getNombre());
  	  	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
	  	  if(s1.ES_REFERENCIA()) {
			pw.println("	DRF");
	  	  }
  	}else if(s1.ES_VARIABLE()){
	  	pw.println("; Leer variable " + s1.getNombre());
	  	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
	  	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
			pw.println("\t RD    1");
	  	}
	  	else{
	  		pw.println("\t RD    0");
		}
	}else if(s1.ES_REFERENCIA()) {
  	  	pw.println("; Leer parametro por referencia" + s1.getNombre());
      	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
      	pw.println("\t DRF");
      	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
    		pw.println("\t RD    1");
  	  	}
  	  	else{
  	  		pw.println("\t RD    0");
  		}
	}
  		}
  ("[" r = expresion(false,false,s1) "]"
  {
	esComponente = true;
  }
  )?
  {
    System.out.println("Entro aqui");
    //Obtenemos el simbolo con el nombre del id
    System.out.println("AccesoComponente en lista asiganbles: " + esComponente);
    if(s1.ES_VECTOR() && !esComponente) {
          String mensaje = "Valor componente ";
	      String aux = "";
	      aux = mensaje + "1: ";
	      for (int x=0;x<=aux.length()-1;x++) { 
			   		pw.println("	STC		" + (int)aux.charAt(x));
			   		pw.println("	WRT		0");
	  	  }
      	  //Es un vector entero hay que ir componente por componente leyendo
//
//      	  if(s1.ES_REFERENCIA()) {
//			pw.println("	DRF");
//      	  }
      	  //La primera componente ya se le ha hecho SRF, solo hay que leerla
      	  if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
	    	pw.println("\t RD    1");
	  	  }
	  	  else{
	  	  	pw.println("\t RD    0");
	  	  }
	      int offset = s1.get_tamanyo_componente();
	      int bytes_componente = s1.get_tamanyo_componente();
	      
	      for(int i = 1; i < s1.getLongitud(); i++) {
				aux = mensaje + (i+1) + ": ";
	        	for (int x=0;x<=aux.length()-1;x++) { 
			   		pw.println("	STC		" + (int)aux.charAt(x));
			   		pw.println("	WRT		0");
	  			}
	  	       	
	  	       	if(s1.ES_REFERENCIA()) {
	  	       	  	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + (s1.getDir()));
					pw.println("	DRF");
					pw.println("	STC	"+ offset);
					pw.println("	PLUS");
	      		}else {
					pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + (s1.getDir()+offset));
	      		}
	  	       	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
	      }
      }else if(s1.ES_VECTOR() && esComponente){
        	System.out.println("Vector y componente");
      	  	if(r.tipo == Simbolo.Tipo_variable.ENTERO) {
				pw.println("	STC " + s1.get_tamanyo_componente());
				pw.println("	TMS	");
				pw.println("	STC " + s1.get_tamanyo_componente());
				pw.println("	SBT	");

      	  	    pw.println("\t PLUS");        	
	          	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	      	}else {
	      	  	System.out.println("Error semantico: Vector mal indexado, no es variable entera - linea "+t1.beginLine + " columna " + t1.beginColumn);
	      	}

  	}
  }
  ( "," t2 = <tID>{
    esComponente = false;
    r = null;//Obtenemos el simbolo con el nombre del id
//    System.out.println("AccesoComponente en lista asiganbles: " + esComponente);
    s2 = tabla_simbolos.buscar_simbolo(t2.image);
    if(s2 == null){
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(!s2.ES_PARAMETRO() &&  !s2.ES_VARIABLE()){
  		 System.out.println("Error semantico: El simbolo no es asignable - linea "+t2.beginLine + " columna " + t2.beginColumn);
  	}else if(s2.ES_VALOR()){
  	    System.out.println("Error semantico: El simbolo no es asignable (PARAMETRO POR VALOR) - linea "+t2.beginLine + " columna " + t2.beginColumn);
  	}else if(s2.ES_VECTOR()) {
  	  	esvector = true;
	    pw.println("; Leer variable vector " + s2.getNombre());
  	  	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
  	  	 if(s2.ES_REFERENCIA()) {
			pw.println("	DRF");
	  	  }
  	  	System.out.println("Lectura de un vector");
  	}else if(s2.ES_VARIABLE()){
	  	pw.println("; Leer variable " + s2.getNombre());
	  	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
	  	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
			pw.println("\t RD    1");
	  	}
	  	else{
	  		pw.println("\t RD    0");
		}
	}else if(s2.ES_REFERENCIA()) {
  	    pw.println("; Leer parametro por referencia " + s2.getNombre());
      	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
      	pw.println("\t DRF");
      	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
    		pw.println("\t RD    1");
  	  	}
  	  	else{
  	  		pw.println("\t RD    0");
  		}
	}
  		}
  ("[" r = expresion(false,false,s2) "]"
  {
		esComponente = true;
  }
  )?
    {
    System.out.println("Entro aqui");
    //Obtenemos el simbolo con el nombre del id
    if(s2.ES_VECTOR() && !esComponente) {
          String mensaje = "Valor componente ";
	      String aux = "";
	      aux = mensaje + "1: ";
	      for (int x=0;x<=aux.length()-1;x++) { 
			   		pw.println("	STC		" + (int)aux.charAt(x));
			   		pw.println("	WRT		0");
	  	  }
      	  //Es un vector entero hay que ir componente por componente leyendo
      	  if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
	    	pw.println("\t RD    1");
	  	  }
	  	  else{
	  	  	pw.println("\t RD    0");
	  	  }
	      int offset = s2.get_tamanyo_componente();
	      int bytes_componente = s2.get_tamanyo_componente();
	      
	      for(int i = 1; i < s2.getLongitud(); i++) {
				aux = mensaje + (i+1) + ": ";
	        	for (int x=0;x<=aux.length()-1;x++) { 
			   		pw.println("	STC		" + (int)aux.charAt(x));
			   		pw.println("	WRT		0");
	  			}
	  	       	
	  	       	if(s2.ES_REFERENCIA()) {
	  	       	  	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + (s2.getDir()));
					pw.println("	DRF");
					pw.println("	STC	"+ offset);
					pw.println("	PLUS");
	      		}else {
					pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + (s2.getDir()+offset));
	      		}
	  	       	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
	      }
      }else if(s2.ES_VECTOR() && esComponente){
        	System.out.println("Vector y componente");
      	  	if(r.tipo == Simbolo.Tipo_variable.ENTERO) {
				pw.println("	STC " + s2.get_tamanyo_componente());
				pw.println("	TMS	");
				pw.println("	STC " + s2.get_tamanyo_componente());
				pw.println("	SBT	");

      	  	    pw.println("\t PLUS");        	
	          	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	      	}else {
	      	  	System.out.println("Error semantico: Vector mal indexado, no es variable entera - linea "+t1.beginLine + " columna " + t1.beginColumn);
	      	}

  	}
  }

  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de asignables");
  }
}

void escribir():
{
  	Token t;
}
{ try {
  t = <tESCRIBIR> { pw.println("; Escritura");}
  "(" lista_escribibles(t) ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al escribir");
  }
}


void lista_escribibles(Token t):
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  
}
{ try {
  //TODO: mirar para escribir los vectores [x,y,z]
  r1 = expresion(false,false,null)
  {  
//    System.out.println("Tipo dentro de escribir " + r1.tipo);
    if(r1.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
		System.out.println("Error semantico: Tipo de variable no legible - linea "+t.beginLine + " columna " + t.beginColumn);
    }
    else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		System.out.println("Error semantico: Tipo de variable no legible - linea "+t.beginLine + " columna " + t.beginColumn);
    }else if(r1.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra

      	for (int x=1;x<r1.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r1.cadena.charAt(x));
	   		pw.println("	WRT		0");
	  	}
	}
	else if (r1.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r1.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}else if(r1.sim.ES_VECTOR()) {
	  		if(r1.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
	  		  	pw.println("	WRT		1");
	  		}else {
	  		 	pw.println("	WRT		0"); 
	  		}
	  		int bytes_componente = r1.sim.get_tamanyo_componente();
	  		int offset = r1.sim.get_tamanyo_componente();
	  		for(int i = 1; i <r1.tam_vec; i++) {
				pw.println(";Escritura variablea la variable " + r1.sim.getNombre());
       	 		pw.println("	SRF	"+  (nivel - r1.sim.getNivel()) + "	" + (r1.sim.getDir()));
       	 		if(r1.sim.ES_REFERENCIA())
       	 			pw.println("	DRF");
					pw.println(";	comprobamos si esta inicializada la variable " + r1.sim.getNombre());
//					pw.println("	DUP");
//					pw.println("	STC 77777");
//					pw.println("	EQ");
//					pw.println("	JMT error_inicializada");

       	 			
       	 		pw.println("	STC	"+ offset);
   	 			pw.println("	PLUS");
       	 		pw.println("	DRF");
       	 		pw.println(";	comprobamos si esta inicializada la variable " + r1.sim.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
       	 		if(r1.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
		  		  	pw.println("	WRT		1");
		  		}else {
		  		 	pw.println("	WRT		0"); 
		  		}
		  		offset+= bytes_componente;
	  		}
	}
  }
  (","r2 = expresion(false,false,null)
   {  
//    System.out.println("Tipo dentro de escribir " + r2.tipo);
    if(r2.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
       System.out.println("Error semantico: Tipo de variable no legible - linea "+t.beginLine + " columna " + t.beginColumn);
    }
    else if(r2.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		System.out.println("Error semantico: Tipo de variable no legible - linea "+t.beginLine + " columna " + t.beginColumn);
    }else if(r2.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra
      	for (int x=1;x<r2.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r2.cadena.charAt(x));
	   		pw.println("	WRT		0");
	  	}
	}
	else if (r2.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r2.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}else if(r2.sim.ES_VECTOR()) {
	  		if(r2.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
	  		  	pw.println("	WRT		1");
	  		}else {
	  		 	pw.println("	WRT		0"); 
	  		}
	  		int bytes_componente = r2.sim.get_tamanyo_componente();
	  		int offset = r2.sim.get_tamanyo_componente();
	  		for(int i = 1; i <r2.tam_vec; i++) {
				pw.println(";Escritura variablea la variable " + r2.sim.getNombre());
       	 		pw.println("	SRF	"+  (nivel - r2.sim.getNivel()) + "	" + (r2.sim.getDir()));
       	 		if(r2.sim.ES_REFERENCIA())
       	 			pw.println("	DRF");
       	 			pw.println(";	comprobamos si esta inicializada la variable " + r2.sim.getNombre());
//					pw.println("	DUP");
//					pw.println("	STC 77777");
//					pw.println("	EQ");
//					pw.println("	JMT error_inicializada");

       	 			
       	 		pw.println("	STC	"+ offset);
   	 			pw.println("	PLUS");
       	 		pw.println("	DRF");
       	 		pw.println(";	comprobamos si esta inicializada la variable " + r2.sim.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
       	 		if(r2.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
		  		  	pw.println("	WRT		1");
		  		}else {
		  		 	pw.println("	WRT		0"); 
		  		}
		  		offset+= bytes_componente;
	  		}
	}
  }
  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de escribibles");
  }
}

void invocacion_accion(Simbolo id,Token id_t):
{
  ArrayList<Simbolo > parametros_necesarios = id.getListaParametros();
//  System.out.println("Se va a invocar una accion cuyos parametros son: "+ parametros_necesarios.toString());
}
{ try {
  argumentos(id,id_t,parametros_necesarios) ";"
  {
     pw.println("; Invocando a " + id.getNombre().toUpperCase());
     pw.println("\t OSF   " + (id.getDir() - 1) + "  " + (nivel - id.getNivel())+ " " + id.getEtiqueta());
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la invocacion de acciones");
  }
}

void asignacion(Simbolo id, RegistroExpr r, Token id_t,boolean ac):
{
  RegistroExpr r1 = new RegistroExpr();
  Simbolo.Tipo_variable tpExp;
  Token t;
  boolean accesoComponente = false;
}
{ try {
  t = <tOPAS> r1 = expresion(false,false,null)
  {
    	System.out.println("El resultado de la expresion es "+ r1.valorBool);
	
	    if(ac && r1.tipo != id.getTipoComponente()) {
	        System.out.println("Error semantico: No coinciden los tipos - linea "+t.beginLine + " columna " + t.beginColumn);
	    	ac = false;
	  	}else if(ac && r1.tipo == id.getTipoComponente()) {
	  	  	System.out.println("Acceso a acomponente y coincide");
	  	  	System.out.println("Entro aqui");
	  	  	if(r1.esVariable) {
	  	  	  pw.println("	DRF");
	  	  	}
	  	  	//TODO: falta si es variable DRF sino na
	  	  	pw.println("	ASG");
	    	ac = false;
	    }else if(id.getVariable() != r1.tipo && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
	  		System.out.println("Error semantico: No coinciden los tipos - linea "+t.beginLine + " columna " + t.beginColumn);
	   	}else if( r1.tipo == Simbolo.Tipo_variable.CADENA) {
	   		System.out.println("Error semantico: Las cadenas de texto no son asignables - linea "+t.beginLine + " columna " + t.beginColumn);
	   	}else if(id.ES_VECTOR()) {
			if(id.getLongitud() != r1.tam_vec) {
				System.out.println("Error semantico: El tamaño de los vectores no coincide - linea "+t.beginLine + " columna " + t.beginColumn);
			}else {
				//System.out.println("Los vectores SI coinciden en tamanyo");

				//TODO: asignar un vector dentro de una funcion pasando otro vector por referencia
				int bytes_componente = id.get_tamanyo_componente();
				int offset = bytes_componente;
				pw.println("	ASG");
				for(int i = 1; i < r1.tam_vec; i++) {
				  	pw.println(";Asignacion componente "+ (i+1));
				  	pw.println("	SRF   " + (nivel - id.getNivel()) + "  " + id.getDir());
				  	if(id.ES_REFERENCIA())
				  		pw.println("	DRF");
				  	pw.println("	STC	" + offset);
				  	pw.println("	PLUS");
					pw.println("	SRF   " + (nivel - r1.sim.getNivel()) + "  " + r1.sim.getDir());
					if(r1.sim.ES_REFERENCIA())
				  		pw.println("	DRF");
				  	pw.println("	STC	" + offset);
				  	pw.println("	PLUS");
        			pw.println("	DRF");

					
					//no estoy seguro de si aqui hace falta hacer la comprobacion
        			pw.println(";	comprobamos si esta inicializada la variable " + id.getNombre());
//					pw.println("	DUP");
//					pw.println("	STC 77777");
//					pw.println("	EQ");
//					pw.println("	JMT error_inicializada");

        			
        			pw.println("	ASG");
        			offset+=bytes_componente;
				}
			}
	   	}else { 
			//Si todo va bien hacemos la asignacion
		   	pw.println("; Asignacion.");
		   	//TODO: esto esta mal xd
//		   	if(r1.esVariable) {
//		   	  	System.out.println("Entro aqui");
//		   	  	pw.println("	DRF");
//		   	}
		    pw.println("	ASG");
	  }
	
  }
  ";"
  } catch (ParseException e) {
     SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en asignacion");
  }
}


void mientras_que():
{
   RegistroExpr r = new RegistroExpr();
   Token t2;
}
{ try {
  t2 = <tMQ>
  {
    
    String etMQ = et.nueva_et();
    pw.println(";MQ");
    pw.println(etMQ + ":");
  }
  r = expresion(false,false,null)
  {
       Token t = getToken(0);
       String etFIN = et.nueva_et();
       pw.println("	JMF	" + etFIN);
  	   if(r.tipo != Simbolo.Tipo_variable.BOOLEANO) {
		System.out.println("Error semantico: Condicion del mientras que no es booleana - linea "+t2.beginLine + " columna " + t2.beginColumn);
    }
  }
  lista_sentencias() <tFMQ>
  {
     
     pw.println("	JMP	" + etMQ);
     pw.println(";FMQ");
     pw.println(etFIN + ":");
     
    
  }
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en mientras que");
  }
}

void seleccion():
{
   RegistroExpr r = new RegistroExpr();
   Token t2;
}
{ try {
  t2=<tSI> {pw.println(";SI" );}
  r = expresion(false,false,null)
  {
    
    String etiqSINO = et.nueva_et();
    //TODO: mirar etiqueta sino si no hay sino
    pw.println("	JMF " + etiqSINO);
    Token t = getToken(0);
    if(r.tipo == Simbolo.Tipo_variable.BOOLEANO && !r.esVariable){
      //TODO mirar este if si hay que ejecutarlo, se puede mirar de eliminar el codigo muerto pasando un booleano
     	if(r.valorBool) {
     	 	System.out.println("Este codigo siempre se va a ejecutar porque es una constante TRUE");
     	}else {
			System.out.println("Este codigo nunca se va a ejecutar porque es una constante FALSE");	
     	}
        
    }else if(r.tipo != Simbolo.Tipo_variable.BOOLEANO ) {
		System.out.println("Error semantico: Condicion de seleccion no es booleana - linea "+t2.beginLine + " columna " + t2.beginColumn);
    }
  }
  <tENT> { pw.println(";ENT" );}
  lista_sentencias()
  {
    
    String etiqFIN= et.nueva_et();
    pw.println("	JMP " + etiqFIN);
    pw.println(etiqSINO +":" );
  }
  ( <tSI_NO>
  {
    
    pw.println(";SI_NO" );
  }
  lista_sentencias() )? <tFSI>
  {
    pw.println(etiqFIN +":" );
    pw.println(";FSI" );
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en seleccion");
  }
}

void argumentos(Simbolo id, Token id_t,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params;
}
{ try {
 ("(" (params = lista_expresiones(id,id_t,parametros_necesarios)
 {
   	//TODO: esto creo que no hace falta
   	if(params.size() != parametros_necesarios.size()) {
   	  	//TODO: gestionar excepciones 
		System.out.println("Error semantico: Los parametros patra invocar a la accion no coinciden. "+ params.size() + " , " + parametros_necesarios.size());
   	}
   	}

  )? ")")?
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en argumentos");
  }
}


ArrayList<RegistroExpr> lista_expresiones(Simbolo id, Token id_t,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params = new ArrayList<RegistroExpr>();
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  int i = 0;
  Simbolo s = new Simbolo();
  //System.out.println("Llego a lista expresiones y el numero de parametros es:" + parametros_necesarios.size());
  
}
{ try {
  r1 = expresion(false,true,null)
  {

    if(parametros_necesarios != null) {
      	if(i >= parametros_necesarios.size()) {
	        System.out.println("Error semantico: Numero de parametros incorrectos - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
	    }else { 
		    s = parametros_necesarios.get(i);
		    System.out.println("Parametro numero " + (i+1) + " de:" + parametros_necesarios.size()  + " tipo_necesario: "+ s.getVariable().toString() + " tipo_pasado: " + r1.tipo.toString()+"y por: " + s.getParametro());
		}
		
	    if(s.getVariable() != r1.tipo) {
			 System.out.println("Error semantico: El tipo de los parametros no coincide - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
		}else if(s.ES_REFERENCIA() && !r1.esVariable) {
		  	//TODO: gestionar excepciones
		  	 System.out.println("Error semantico: Se esperaba un parametro por referencia, no por valor - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
		}else if(s.ES_VALOR() && r1.esVariable && !r1.valor_hecho) {
		    pw.println(";Variable por valor anado DRF");
		  	pw.println("	DRF");
		}
		i++;
	    params.add(r1);
	}
  }
  ( "," r2 = expresion(false,true,null)
  {
    if(parametros_necesarios != null) {
      	if(i >= parametros_necesarios.size()) {
	        System.out.println("Numero de parametros incorrectos - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
	    }else { 
		    s = parametros_necesarios.get(i);
		    //System.out.println("Parametro numero " + (i+1) + " de:" + parametros_necesarios.size()  + " tipo_necesario: "+ s.getVariable().toString() + " tipo_pasado: " + r2.tipo.toString());
		}
	    if(s.getVariable() != r2.tipo) {
			 System.out.println("Error semantico: El tipo de los parametros no coincide - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
		}else if(s.ES_REFERENCIA()&& !r2.esVariable) {
		  	System.out.println("Error semantico: Se esperaba un parametro por referencia, no por valor - linea "+id_t.beginLine + " columna " + id_t.beginColumn);
		}else if(s.ES_VALOR() && r2.esVariable) {
		  	pw.println("	DRF");
		}
		i++;
	    params.add(r2);
	}
  }
  )*
 {
   return params;
 }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de expresiones");
  }
}


Token operador_multiplicativo():
{
  Token t;
}
{ try {
  ( t = <tMUL>{return t;}
  | t = <tAND>{return t;}
  | t = <tDIV>{return t;}
  | t = <tMOD>{return t;}
  )
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador multiplicativo");
  }
}

Token operador_aditivo():
{
  Token t;
}
{ try {
  ( t = <tMAS>{return t;}
  | t = <tMENOS>{return t;}
  | t = <tOR>{return t;}
  )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador aditivo");
  }
}

Token operador_relacional():
{
  Token t;
}
{ try {
  ( t = <tMAYOR>{return t;}
  | t = <tMENOR>{return t;}
  | t = <tIGUAL>{return t;}
  | t = <tMAI>{return t;}
  | t = <tMEI>{return t;}
  | t = <tNI>{return t;}
   )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador relacional");
  }
}

RegistroExpr expresion(boolean vec,boolean invoc_acc,Simbolo sim):
{ 
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  	r1 = expresion_simple(vec,invoc_acc,sim)
  	{
  	  //System.out.println("El tipo de r1 es: " + r1.tipo.toString());
	  result = r1;
  	}
  	( t = operador_relacional() r2 = expresion_simple(vec,invoc_acc,sim) 
  	{
  	  boolean ok = true;
	  String operacion = t.image;
		  switch(operacion) { 
		  		case ">":
		  			pw.println("	GT");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r1.tipo != Simbolo.Tipo_variable.CHAR) {
						System.out.println("Operando incompatible con > - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR) {
							System.out.println("Operando incompatible con > - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
							  	
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) {
									result.valorBool = r1.valorChar > r2.valorChar;
								}else {
									result.valorBool =	result.valorEnt > r2.valorEnt;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  					
		  					 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<":
		  			pw.println("	LT");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO&& r1.tipo != Simbolo.Tipo_variable.CHAR) {
		  			  	System.out.println("Operando incompatible con < - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR) {
			  			  	System.out.println("Operando incompatible con < - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
							  	
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) {
									result.valorBool = r1.valorChar < r2.valorChar;
								}else {
									result.valorBool =	result.valorEnt < r2.valorEnt;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  					
		  					 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case ">=":
		  			pw.println("	GTE");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO&& r1.tipo != Simbolo.Tipo_variable.CHAR) {
		  			  	System.out.println("Operando incompatible con >= - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR) {
			  			  	System.out.println("Operando incompatible con >= - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok){
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
							  
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) {
									result.valorBool = r1.valorChar >= r2.valorChar;
								}else {
									result.valorBool =	result.valorEnt >= r2.valorEnt;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  					
		  					 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<=":
		  			pw.println("	LTE");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO&& r1.tipo != Simbolo.Tipo_variable.CHAR) {
		  			  	System.out.println("Operando incompatible con <= - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR) {
			  			  	System.out.println("Operando incompatible con <= - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
							  	
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) {
									result.valorBool = r1.valorChar <= r2.valorChar;
								}else {
									result.valorBool =	result.valorEnt <= r2.valorEnt;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "=":
		  			
		  			pw.println("	EQ");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO&& r1.tipo != Simbolo.Tipo_variable.CHAR && r1.tipo != Simbolo.Tipo_variable.BOOLEANO ) {
		  			  	System.out.println("Operando incompatible con = - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR && r2.tipo != Simbolo.Tipo_variable.BOOLEANO) {
			  			  	System.out.println("Operando incompatible con = - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) {
									result.valorBool = r1.valorChar == r2.valorChar;
								}else if(r1.tipo == Simbolo.Tipo_variable.ENTERO){
									result.valorBool =	result.valorEnt == r2.valorEnt;
								}else {
								  result.valorBool =	result.valorBool == r2.valorBool;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<>":
		  			pw.println("	NEQ");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r1.tipo != Simbolo.Tipo_variable.CHAR && r1.tipo != Simbolo.Tipo_variable.BOOLEANO) {
		  			  	System.out.println("Operando incompatible con <> - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO && r2.tipo != Simbolo.Tipo_variable.CHAR && r2.tipo != Simbolo.Tipo_variable.BOOLEANO) {
			  			  	System.out.println("Operando incompatible con <> - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.tipo == r2.tipo) {
							  	if(r1.esVariable || r2.esVariable)
									result.esVariable = true;
								if(r1.tipo ==Simbolo.Tipo_variable.CHAR) { 	
									result.valorBool = r1.valorChar != r2.valorChar;
								}else if(r1.tipo == Simbolo.Tipo_variable.ENTERO){
									result.valorBool =	result.valorEnt != r2.valorEnt;
								}else {
								  result.valorBool =	result.valorBool != r2.valorBool;
								}
								result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
							}else {
								System.out.println("No coinciden los tipos en " + operacion +" - linea "+t.beginLine + " columna " + t.beginColumn);
							}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }
  	}
  	)* {
  	  //System.out.println("Voy a devolver result:" + result.tipo);
  	  return result;
  	  }
}

RegistroExpr expresion_simple(boolean vec, boolean invoc_acc,Simbolo sim):
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
	r1 = termino(vec,invoc_acc,sim) {
     result = r1;
	  
	}(t = operador_aditivo() r2 = termino(vec,invoc_acc,sim)
	{

	 
	  boolean ok = true;
	  String operacion = t.image;
		  switch(operacion.toLowerCase()) { 
		  		case "+":
		  			pw.println("	PLUS");
		  			//System.out.println("Detectado +");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("Operando incompatible con SUMA - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("Operando incompatible con SUMA - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  				  	if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					if ( r2.valorEnt > Long.MAX_VALUE - result.valorEnt && r2.valorEnt > 0 && result.valorEnt > 0) {
		  					  	System.out.println("Desbordamiento en SUMA - linea "+t.beginLine + " columna " + t.beginColumn);
							}
							else { 
		  						result.valorEnt =	result.valorEnt + r2.valorEnt;
		  					}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "-":
		  			pw.println("	SBT");
		  			//System.out.println("Detectado -");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("Operando incompatible con RESTA - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("Operando incompatible con RESTA - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  	if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt - r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
					break;
		  		case "or":
		  			pw.println("	OR");
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("Operando incompatible con OR - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es booleano o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							System.out.println("Operando incompatible con OR - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorBool | r2.valorBool; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }

	}
	)*
	{
	  //System.out.println("Voy a devolver result:" + result.tipo);
	  return result;
	}
}


RegistroExpr termino(boolean vec, boolean invoc_acc,Simbolo sim):
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  RegistroExpr ant = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  
  r1 = factor(vec,invoc_acc,sim)
  {
    result = r1;
    ant = r1;
  }

  ( t = operador_multiplicativo() r2 = factor(vec,invoc_acc,sim)
  { 
	  boolean ok = true;
	  String operacion = t.image;
  		  //Hay que hacer lowercase porque aunque el analizador sea case insensitive, el switch reconoce la diferencia entre mayusculas y minusculas
		  switch(operacion.toLowerCase()) { 
		  		case "*":
		  			pw.println("	TMS");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("Operando incompatible con MUL - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("Operando incompatible con MUL - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					if (result.valorEnt != 0 && r2.valorEnt > Long.MAX_VALUE / result.valorEnt && r2.valorEnt > 0 && result.valorEnt > 0) {
							    System.out.println("Desbordamiendo en MUL - linea "+t.beginLine + " columna " + t.beginColumn);
							}else { 
		  						result.valorEnt =	result.valorEnt * r2.valorEnt;
		  					}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "mod":
		  			pw.println("	MOD");
		  			//System.out.println("Detectado mod");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
						System.out.println("Operando incompatible con MOD - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("Operando incompatible con MOD - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  			  //Mirar si esto va bien
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							result.tipo =  Simbolo.Tipo_variable.ENTERO;
							if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  				    if(!r2.esVariable) {
		  				      	if(r2.valorEnt == 0) {
		  				      	  	System.out.println("Detectado MOD por 0 - linea "+t.beginLine + " columna " + t.beginColumn);
		  				      	}else {
		  				      	  	result.valorEnt =	result.valorEnt % r2.valorEnt;
		  				      	}
		  					}
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
					break;
		  		case "div":
		  			pw.println("	DIV");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("Operando incompatible con DIV - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							System.out.println("Operando incompatible con DIV - linea "+t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
							if(!r2.esVariable) {
								if(r2.valorEnt != 0)
									result.valorEnt =	result.valorEnt / r2.valorEnt;
								else
									System.out.println("Detectada disivision por 0 - linea "+t.beginLine + " columna " + t.beginColumn);
								  
							}
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "and":
		  			pw.println("	AND");	
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {	
		 			  	System.out.println("Operando incompatible con AND - linea "+t.beginLine + " columna " + t.beginColumn);
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							System.out.println("Operando incompatible con AND - linea "+ t.beginLine + " columna " + t.beginColumn);
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							if(r1.esVariable || r2.esVariable)
								result.esVariable = true;
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					//TODO: mirar si una de las dos no es variable y es false pues false
		  					result.valorBool =	result.valorBool && r2.valorBool;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  			
		  }
  }
  )*
  {
    //System.out.println("Voy a devolver result:" + result.tipo);
    return result;
  }
  
}

/*("-" factor()
	| <tNOT> factor()
	| "(" expresion() ")"
	| <tENTACAR> "(" expresion() ")"
	| <tCARAENT> "(" expresion() ")"
	| <tID>
	| <tNUM>
	| <tCAR>
	| <tCADENA>
	| <tTRUE>| <tFALSE>)*/

RegistroExpr factor(boolean vec, boolean invoc_acc,Simbolo sim):
{
  RegistroExpr re = null;
  Token t;
  Simbolo s;
}
{
  ("-" re = factor(vec, invoc_acc,sim)
  {
    pw.println("	NGI");
    if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
//			System.out.println("El tipo de la variable no es compatible con \"-\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.ENTERO) {
		re.valorEnt = -re.valorEnt;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }
  
  | <tNOT> re = factor(vec,invoc_acc,sim)
  {
    pw.println("	NGB");
    if(re.tipo != Simbolo.Tipo_variable.BOOLEANO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
//			System.out.println("El tipo de la variable no es compatible con \"NOT\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.BOOLEANO) {
		re.valorBool = !re.valorBool;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }

  //TODO: descomentar esto cuando ya vaya expresion
  | "(" re = expresion(vec, invoc_acc,sim) ")"
  {
    //Si solo hay parentesis hay que devolver lo que hay dentro de los parentesis
    return re;
  }

  
  | t = <tENTACAR> "(" re =expresion(vec,invoc_acc,sim) ")"
  {
  	if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
//		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.CHAR;
		new_r.valorChar = (char)re.valorEnt;
		return new_r;
    }
    
    
    
  }
  | <tCARAENT> "(" re = expresion(vec,invoc_acc,sim) ")"
  {
    if(re.tipo != Simbolo.Tipo_variable.CHAR && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
//		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.ENTERO;
		new_r.valorEnt = (int)re.valorChar;
		return new_r;
    }
    
  }
  //TODO: vector
  | t = <tID>
  {
     re = null;
     boolean esvector = false;
     s = tabla_simbolos.buscar_simbolo(t.image);
     pw.println(";Acceso a la variable " + t.image);
     if(s == null) {
		System.out.println("Error semantico: No he encontrado simbolo. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
     	//TODO: no existe el simbolo hay que lanzar una exepcion
     }  else if(s.ES_ACCION()) {
        System.out.println("Error semantico: He encontrado una accion. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
     	//TODO: no existe el simbolo hay que lanzar una exepcion
     } else if(s.ES_VECTOR()) {
        System.out.println("He encontrado un vector "+ t.image);
        pw.println("; Acceso al vector " + s.getNombre());
       	pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.getDir());
		esvector = true;
   	 }else {
   	 	//Caso variable normal
       	re = new  RegistroExpr();
       	if(s.ES_VALOR()) {
				System.out.println("Es un parametro por valoor");
       	}
	    pw.println("; Acceso a la variable " + s.getNombre());
       	pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.getDir());
       	
       	//Estamos en una invocacion de la accion
       	if(!invoc_acc){
       	  	pw.println("	DRF");
//       	  	pw.println(";	comprobamos si esta inicializada la variable " + s.getNombre());
//			pw.println("	DUP");
//			pw.println("	STC 77777");
//			pw.println("	EQ");
//			pw.println("	JMT error_inicializada");
       	 	if(s.ES_REFERENCIA()){
       	 	  	//Si es por referencia hay que hacer otro drf ya que el primero solo obtiene la direccion de la variable
       	 	  	pw.println("	DRF");
       	 	  	pw.println(";	comprobamos si esta inicializada la variable " + s.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
       	    }
       	}else if(invoc_acc) {
       	    
			if(s.ES_VALOR()) {
//			  	System.out.println("Eyeyeyyeyyeye");
			  	re.valor_hecho = true;
			  	
			  	pw.println("	DRF");
			  	pw.println(";	comprobamos si esta inicializada la variable " + s.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
			}
       	}
	    re.tipo = s.getVariable();
	    re.s = s.getTipo();
	    re.esVariable = true;
	    re.sim = s;
	    return re;
	}

  }("["re = expresion(false,false,s)"]")?
  {
    if(esvector) {
     	if(re != null) {
     	   	if(re.esVariable) {
     	   	    re = new  RegistroExpr();
     	   	    System.out.println(";Se ha indexado con una variable");
				pw.println(";Se ha indexado con una variable");
				re.tipo = s.getTipoComponente();
				re.esVariable = true;
				pw.println("	STC	" + s.get_tamanyo_componente());
          		pw.println("	TMS");
          		pw.println("	STC	" + s.get_tamanyo_componente());
          		pw.println("	SBT");
				pw.println("	PLUS");
				if(!invoc_acc)
					pw.println("	DRF");
				return re;
 		   	}else {
 		     	//Caso es una constante
 		     	if(re.tipo != Simbolo.Tipo_variable.ENTERO) {
// 		       		System.out.println("Error semantico: Se ha detectado una varieable vector y no es constante entera. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
 		       		//TODO: expeciones tiene que ser una constante entera
 		     	}else {
 		        	if(re.valorEnt <= 0) {
// 		          		System.out.println("Error semantico: Se ha detectado una variable vector y no es positivo. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
 		          		//TODO: excepciones tiene que ser una constante positiva
 		        	}else if(re.valorEnt > s.getLongitud()){
// 		        	  System.out.println("Overflow vectores");
 		          		//TODO: Excepcion overflow indexacion
 		        	  
 		        	}else {
// 		          		System.out.println("aaSe ha detectado una varieable vector llamada: " + t.image +" y de tam: "+re.valorEnt + " y se puede declarar");
 		          		//Se puede declarar el vector
 		          		Simbolo.Tipo_variable tipo_aux = s.getTipoComponente();
 		          		re.tipo = tipo_aux;
					    re.s = s.getTipo();
					    re.esVariable = true;
					    re.sim = s;
 		          		pw.println("; Acceso a la variable " + s.getNombre() + "[" + re.valorEnt+ "]");
 		          		pw.println("	STC	" + s.get_tamanyo_componente());
 		          		pw.println("	TMS");
 		          		pw.println("	STC	" + s.get_tamanyo_componente());
 		          		pw.println("	SBT");
 		          		//TODO: Mirar si el plus si que tiene que estar a[1] = 2 por ejemplo
 		          		pw.println("	PLUS");
				       	//pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.calcularDesplazamientoDireccion(re.valorEnt -1));
						if(!invoc_acc)
				       		pw.println("	DRF");
					    
					    return re;
		       		}
     			}
     		}
     	}else {
     	  	System.out.println("He encontrado vector entero");
     	  	re = new  RegistroExpr();
 			re.tipo = s.getVariable();
     	  	//Es un vector entero
     		re.tam_vec = s.getLongitud();
		    re.esVariable = true;
		    re.sim = s;
		    if(!invoc_acc){
	       	  	pw.println("	DRF");
	       	  	pw.println(";	comprobamos si esta inicializada la variable " + s.getNombre());
//				pw.println("	DUP");
//				pw.println("	STC 77777");
//				pw.println("	EQ");
//				pw.println("	JMT error_inicializada");
	       	 	if(s.ES_REFERENCIA()){
	       	 	  	//Si es por referencia hay que hacer otro drf ya que el primero solo obtiene la direccion de la variable
	       	 	  	pw.println("	DRF");
	       	 	  	pw.println(";	comprobamos si esta inicializada la variable " + s.getNombre());
//					pw.println("	DUP");
//					pw.println("	STC 77777");
//					pw.println("	EQ");
//					pw.println("	JMT error_inicializada");
	       	    }
       		}
		   
		    return re;
     	}
    }else {
      //TODO: excepciones no se puede indexar algo que no sea un vector
    }
  }
     
  | t  = <tNUM>
  {
	if(!vec){ 
	   		pw.println("	STC   " + t.image);
		}
     
  	return RegistroExpr.ENTERO(t.image);
  }
  | t = <tCAR>
  {
     pw.println("	STC   " + t.image);
     return RegistroExpr.CHAR(t.image);
  }
	
  | t = <tCADENA>
  {
     pw.println(";cadena	" + t.image);
     return RegistroExpr.CADENA(t.image);
  }
  | <tTRUE>
  {
     pw.println("	STC   1" );
     return RegistroExpr.BOOL(true);
  }
  | t = <tFALSE>)
  {
     pw.println("	STC   0" );
     return RegistroExpr.BOOL(false);
  }
}