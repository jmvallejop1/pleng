/**
 * EspecificaciÃ³n JavaCC para la PrÃ¡ctica 2 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.2 - 2021/03/08
 */

//TODO IMPORTNTE: comprobacion overflow lado derecho asignacion
//Hay algo mal en las direcciones
options
{
  static = true;
  //hacemos el leguaje case insenstive, ignoramos la diferencia entre mayusculas y minusculas.
  ignore_case = true;
}

PARSER_BEGIN(MiniLengCompiler)
package compiler;
import java.io.*;
import semantico.*;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.PrintWriter;


public class MiniLengCompiler
{


  public static class RegistroExpr {
	int valorEnt;
	boolean valorBool;
	char valorChar;
	boolean esVariable = false;
	String cadena;
	Simbolo.Tipo_variable tipo;
	Simbolo.Tipo_simbolo s;
	int tam_vec = -1;
	Simbolo sim = null;

	//Devuelve un Registro expresion booleano 
	public static RegistroExpr BOOL(boolean b) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.BOOLEANO;
		reg.valorBool = b;
		return reg;
	}
	//Devuelve un Registro de tipo Entero
	public static RegistroExpr ENTERO(String entero) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.ENTERO;
		reg.valorEnt = Integer.parseInt(entero);
		return reg;
	}
	//Devuelve un Registro de tipo Char
	public static RegistroExpr CHAR(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CHAR;
		reg.valorChar = c.charAt(0);
		return reg;
	}
	
	//Devuelve un Registro de tipo cadena
	public static RegistroExpr CADENA(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CADENA;
		reg.cadena = c;
		return reg;
	}
	
//	//Devuelve un Registro de tipo desconocido
//	public static RegistroExpr DESCONOCIDO() {
//		RegistroExpr reg = new RegistroExpr();
//		reg.tipo = Simbolo.Tipo_variable.DESCONOCIDO;
//		reg.variable = true;
//		return reg;
//	}
//	
	}

  public static Etiqueta et = new Etiqueta();
  //Declaracion print writer para escribir el fichero .code
  public static PrintWriter pw;
	
  //Declaraciones necesarias para tablla de simbolos
  static int nivel = 0;
  static final int INICIAL = 3;

  //Inicializacion de la direccion para aï¿½adir a la tabla de simbolos
  
  public static int dir = INICIAL;
  public static int dir0 = INICIAL;
  public static int dir_a = INICIAL;
  
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  public static void main(String args []) throws ParseException
  {
    //Pasamos como parametro el fichero que queremos compilar
    //Intentamos leer el fichero 
    try {
      	  System.out.println(args[0]);
	      FileInputStream F = new FileInputStream(args[0]);
	      System.setIn(F);
	}catch (Exception e) {
	   //Si no encuentra fichero lee de la entrada estandar
	    System.out.println("Leyendo de la entrada estandar...");
    }
    
   
	 try {
	   		 //TODO: camviar esto por el nombre del fichero + code
	   		 File cod_inter = new File("C:\\Users\\Jmval\\OneDrive\\Escritorio\\pleng\\p2\\codigo_intermedio\\pruebas.code");
    		 FileWriter fichero_salida = new FileWriter(cod_inter);
   			 pw = new PrintWriter(fichero_salida);
	         MiniLengCompiler parser = new MiniLengCompiler(System.in);
	   		 tabla_simbolos.inicializar_tabla();
	   		 MiniLengCompiler.programa();
	  }catch (TokenMgrError e) {
	      try {
	           //gestion de los errores lexicos
		       int linea = SimpleCharStream.getBeginLine();
		       int columna = SimpleCharStream.getBeginColumn();
		       char c = SimpleCharStream.readChar();
	           LexicalErrorManager.printLexicalError(linea,columna,c);
	      }catch(Exception ex){}  
		}
		//TODO:gestionar excepcion del print writer
		catch (IOException e) { }
 	 }
}

PARSER_END(MiniLengCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMENTARIO
| "%%": COMENTARIO_MULTILINEA
}

< COMENTARIO_MULTILINEA> SKIP:
{
  "%%": DEFAULT
  | < ~[] >  
}


< COMENTARIO >SKIP: {
	"\n":DEFAULT
	| < ~[] >  
}



TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
| < tMETODO : "metodo" >
 | < tPROGRAMA : "programa" >
| < tAND : "and" >
| < tOR : "or" >
| < tNOT : "not" >
| < tPRINCIPIO : "principio" >
| < tFIN : "fin" >
| < tSI : "si" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tFSI : "fsi" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >
| < tMOD : "mod" >
| < tTRUE : "true" >
| < tFALSE : "false" >
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
| < tACCION : "accion" >
| < tVAL : "val" >
| < tREF : "ref" >

}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
}



TOKEN : /* OPERADORES */
{
  <  tIGUAL : "=" >
| <  tFIN_SENTENCIA : ";" >
| <  tMAYOR : ">" >
| <  tMENOR : "<" >
| <  tMAI : ">=" >
| <  tMEI : "<=" >
| <  tNI : "<>" >
| <  tOPAS : ":=" >
| <  tMUL : "*" >
| <  tDIV : "div" >
| <  tMAS : "+" >
| <  tMENOS : "-" >
}

TOKEN : /* VALORES */
{
< tID : ((( < tLetra > | "_" )(<tLetra> | "_" | <tCifra>)* (<tLetra> | <tCifra>))) | < tLetra > >
| < tIDv: "vector"/*((( < tLetra > | "_" )(<tLetra> | "_" | <tCifra>)* (<tLetra> | <tCifra>))) "[" (<tCifra>)+ "]" | < tLetra > "[" (<tCifra>)+ "]"*/>
{
  System.out.println("he encontrado un vector");
}
| < tNUM : (<tCifra>)+ >
| <  tCAR : "\"" (<tLetra> | <tCifra> | <tSigno> | " " | "." | "," | ";" | "*" | ":" | "(" | ")" | "/" | "?"| "ï¿½") "\"" >
| <  tCADENA : "\"" (<tLetra> |<tSigno>|<tSigno>| " "|"."|","|";"|"*"|":"|"("|")"|"/"|"?")+  "\"" >
| <  tCifra : ["0"-"9"] >
| <  tLetra: ["a"-"z"] >
| <tSigno: "+" | "-" >
}

/*ANALIZADOR SINTACTICO*/

void programa():
{
  Token programa;
}
{
 try {
	 <tPROGRAMA> programa = <tID>
	 {
	  Simbolo p = new Simbolo();
	  p = tabla_simbolos.introducir_programa(programa.image,dir);
	  dir++;
	  //Escribimos en el fichero de codigo intermedio el programa
	  System.out.println("Voy a escribir probrama en .code");
	  
	  pw.println("; Programa " + programa.image + ".");
	  //Introducimos la primera intruccion de inicio de programa
	  String et_p = et.nueva_et();
	  pw.println("	ENP  " + et_p);
	  
	  //tabla_simbolos.imprimirTabla();
	 }";" 
	 declaracion_variables()
	 {
	   pw.println("; Comienzo del programa " + programa.image);
	 }
	 declaracion_acciones()
	 {
	   pw.println(et_p + ":");
	 }
	 bloque_sentencias(p, et_p)
	 {
		pw.println("; Fin del programa " + programa.image);
      	pw.println("LVP");
	 }
	 {
	   pw.close();
	 }
 }catch (ParseException e) {
//    System.out.println("1");
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la creacion del programa");
  }
}



void declaracion_variables():
{
}
{ try {
    (declaracion()";")*
  } catch (ParseException e) {
      //TODO: idea->crear una variable booleana que indique que ha ocurrido un error
          SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la declaracion de variables");
    }
}

void declaracion():
{
  Simbolo.Tipo_variable tipo;
}
{ 
  tipo = tipo_variables() (identificadores(tipo))
}

Simbolo.Tipo_variable tipo_variables():
{
}
{ try {
  < tENTERO >	{return Simbolo.Tipo_variable.ENTERO;}
  | < tBOOLEANO >	{return Simbolo.Tipo_variable.BOOLEANO;}
  | < tCARACTER > {return Simbolo.Tipo_variable.CHAR;}
} catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el tipo de las variables");
  }
}


//TODO: cambiar tamaño de la variable del vector por TIPO * longitud
void identificadores(Simbolo.Tipo_variable tipo):
{
  Token id1 = null;
  Token id2 = null;
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
  Simbolo.Tipo_variable tipo_aux = null;
  RegistroExpr r = null;
  boolean esVector = false;
}
{
  try {
  	 (
  	   id1 = < tID >
  	   {
  	     r = null;
  	      esVector = false;
  	   }
  	   ("[" r = expresion(false)"]"
  	   {
  	     	
  	    	esVector = true;
  	    	
  	   })?)
	  {
	    try {
	 		if(esVector) {
	 		   if(r.esVariable) {
	 		     //TODO: excepciones, tiene que ser una constante positiva, no una variable
//	 		     System.out.println("Error semantico: Se ha detectado una varieable vector y es un identificador no cont entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		   }else {
	 		     //Caso es una constante
	 		     if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
//	 		       System.out.println("Error semantico: Se ha detectado una varieable vector y no es constante entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		       //TODO: expeciones tiene que ser una constante entera
	 		     }else {
	 		        if(r.valorEnt <= 0) {
//	 		          System.out.println("Error semantico: Se ha detectado una varieable vector y no es positivo. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		          //TODO: excepciones tiene que ser una constante positiva
	 		        }else {
//	 		          System.out.println("Se ha detectado una varieable vector llamada: " + id1.image +" y de tam: "+r.valorEnt + " y se puede declarar");
	 		          //Se puede declarar el vector
	 		          if(tipo == Simbolo.Tipo_variable.ENTERO) {
			            tipo_aux = Simbolo.Tipo_variable.VECENT;
			          }else if(tipo == Simbolo.Tipo_variable.CHAR) {
			            tipo_aux = Simbolo.Tipo_variable.VECCHAR;
			          }else {
			            tipo_aux = Simbolo.Tipo_variable.VECBOOL;
			          }
	 		          s1 = tabla_simbolos.introducir_variable_vector(id1.image,tipo_aux,r.valorEnt, nivel,dir);
	 		          
						//System.out.println("Voy a aumentar el tamaño en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
						//TODO: cambiar get tamanyo para que devuelva longitud * tipovec
	 		          dir += s1.get_tamanyo();
	 		        }
	 		     }
	 		   }
	 		}else {
	 			System.out.println("Se ha detectado una variable normal, se procede con normalidad");
	 		  	s1 = tabla_simbolos.introducir_variable(id1.image,tipo,nivel,dir);
				//System.out.println("Voy a aumentar el tamaño en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
				dir += s1.get_tamanyo();
	 		} 	
	  	}catch(SimboloYaDeclaradoException e2) {
//	  	  	System.out.println("Error  semantico: identificador duplicado: " + id1.image + ". En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	  	}
	  }
	("," (id2 = < tID >
	 {
  	     r = null;
  	     esVector = false;
  	   }
	("[" r = expresion(false)"]"
	{
  	     esVector = true;
  	}
  	)?)
  	{
	    try {
	      if(esVector) {
	 		   if(r.esVariable) {
	 		     //TODO: excepciones, tiene que ser una constante positiva, no una variable
	 		     System.out.println("Error semantico: Se ha detectado una varieable vector y es un identificador no const entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		   }else {
	 		     //Caso es una constante
	 		     if(r.tipo != Simbolo.Tipo_variable.ENTERO) {
	 		       System.out.println("Error semantico: Se ha detectado una varieable vector y no es constante entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		       //TODO: expeciones tiene que ser una constante entera
	 		     }else {
	 		        if(r.valorEnt <= 0) {
	 		          System.out.println("Error semantico: Se ha detectado una varieable vector y no es positivo. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	 		          //TODO: excepciones tiene que ser una constante positiva
	 		        }else {
	 		          System.out.println("Se ha detectado una varieable vector y se puede declarar");
	 		          //Se puede declarar el vector
	 		          if(tipo == Simbolo.Tipo_variable.ENTERO) {
			            tipo_aux = Simbolo.Tipo_variable.VECENT;
			          }else if(tipo == Simbolo.Tipo_variable.CHAR) {
			            tipo_aux = Simbolo.Tipo_variable.VECCHAR;
			          }else {
			            tipo_aux = Simbolo.Tipo_variable.VECBOOL;
			          }
	 		          s2 = tabla_simbolos.introducir_variable_vector(id2.image,tipo_aux,r.valorEnt, nivel,dir);
				//System.out.println("Voy a aumentar el tamaño en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
	 		          
						//TODO: cambiar get tamanyo para que devuelva longitud * tipovec
	 		          dir += s2.get_tamanyo();
	 		        }
	 		     }
	 		   }
	 		}else {
	 			System.out.println("Se ha detectado una varieable normal, se procede con normalidad");
	 		  	s2 = tabla_simbolos.introducir_variable(id2.image,tipo,nivel,dir);
				//System.out.println("Voy a aumentar el tamaño en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
				dir += s2.get_tamanyo();
	 		}
	 		esVector = false;
	  	}catch(SimboloYaDeclaradoException e2) {
	  	  	System.out.println("Error  semantico");
	  	}
	  }
  	)*
  
  } catch (ParseException e) {   
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el identificador");
  }
}

void declaracion_acciones():
{
}
{
  (declaracion_accion())*
}

// (cabecera_accion())";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias())
void declaracion_accion():
{
  	 String etACC = et.nueva_et();
	 Simbolo sim = new Simbolo();
	 String s = new String();
}
{
  (sim = cabecera_accion(etACC))";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias(sim,etACC))
  {

    	dir = sim.getDir();
    	pw.println("; Fin de la accion " + s);
     	pw.println("CSF");
	    //tabla_simbolos.imprimirTabla();
	    //System.out.println("Voy a eliminar las variables del nivel " + nivel);
	    tabla_simbolos.eliminar_variables(nivel);
	    //System.out.println("Voy a eliminar acciones");
	    tabla_simbolos.ocultar_parametros(nivel);
	    tabla_simbolos.eliminar_acciones(nivel);
	    tabla_simbolos.eliminar_parametros_ocultos(nivel+1);
	    nivel--;
//	    if(nivel == 0) {
//			dir = dir0;
//	    }else {
//			dir = dir_a;
//	    }
		dir++;
  }
}

Simbolo cabecera_accion(String etACC):
{
    Token id_accion;
    Simbolo simbolo_accion = null;
    boolean ok;
}
{
  ((<tACCION> id_accion = <tID>
  {
    try {
      	//Justo despues de registrar la accion en la tabla de simbolos, incrementamos el nivel en uno.
      	simbolo_accion = tabla_simbolos.introducir_accion(id_accion.image,nivel,dir,etACC);
      	
      	//System.out.println("Voy a aumrntar el nivel " + (nivel +1));
      	dir = INICIAL;
	    nivel++;
//	    if(nivel-1 ==0){
//	  	  dir0 = dir;
//	  	}else {
//	  	  dir_a= dir;
//
//	  	}
//	  	dir = INICIAL;
	   
	}catch(SimboloYaDeclaradoException e2) {
	  	//System.out.println("Error  semantico: Identificador duplicado: " + id_accion.image() + " En la linea " + id_accion.beginLine + " y la columna " + id_accion.beginColumn);
	}
  }
  //le pasamos a los parametros formales el simbolo de la accion a la que pertenecen para asi poder relacionarlos.
  ) parametros_formales(simbolo_accion))
  {
    tabla_simbolos.imprimirTabla();
    return simbolo_accion;
  }
}

void parametros_formales(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos pasando el simbolo de la accion para poder asiciarla con los parametros
	("("(lista_parametros(simbolo_accion))")")?
  } catch (ParseException e) {   
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros formales");
  }
}

void lista_parametros(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos propagando el simbolo de la accion para poder asociarla
	parametros(simbolo_accion)(";"parametros(simbolo_accion))*
  } catch (ParseException e) {
       SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de parametros");
  }
}


void parametros(Simbolo simbolo_accion):
{
  Simbolo.Clase_parametro clase;
  Simbolo.Tipo_variable tipo;
  Token id1;
  Token id2;
  Simbolo param;
  Simbolo param2;
  RegistroExpr r= null;
}
{ try {
  	//Obtenemos la clase y el timpod el parametro que queremos introducir
	(clase = clase_parametros() tipo = tipo_variables()  id1 = < tID > ("[" r = expresion(false) "]")?
	{
	  try {
	    if(r== null) {
	       //System.out.println("Voy a introduxir un parametro" + simbolo_accion.getNombre() +" "+ id1.image);
	    	//introducimos el parametro actual en la tabla de simbolos
	    	param = tabla_simbolos.introducir_parametro(id1.image,tipo, clase, nivel,dir);
			dir+=param.get_tamanyo();
	    	//Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
	    	simbolo_accion.addParametro(param);
	    	//System.out.println("Aï¿½adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
	    }else{
	      	//Caso vector
	      	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
	      	  	System.out.println("Se declara un vector como parametro");
	      	  	//El vector esta bien definido
	      	  	Simbolo.Tipo_variable tipo_aux = null;
	      	  	if(tipo == Simbolo.Tipo_variable.ENTERO) {
	            	tipo_aux = Simbolo.Tipo_variable.VECENT;
	          	}else if(tipo == Simbolo.Tipo_variable.CHAR) {
	            	tipo_aux = Simbolo.Tipo_variable.VECCHAR;
	          	}else {
	            	tipo_aux = Simbolo.Tipo_variable.VECBOOL;
	          	}
	      	  	param = tabla_simbolos.introducir_parametro_vector(id1.image, tipo_aux, clase, r.valorEnt, nivel, dir);
	      	  	dir += param.get_tamanyo();
	      	  	System.out.println("He introducido el vector a la lista de params");
	      	  	simbolo_accion.addParametro(param);
	      	}else {
	      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
	      	  	//System.out.println("Errpr semantico: No se puede declarar un vector sin una constante entera. En la linea " + id1.beginLine + " y la columna " + id1.beginColumn);
	      	}
	      	
	      	 
	    }
	   
	    
	    
	    
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("El simbolo declarado ya existe");
	  }
	}



	(","id2 = < tID > ("[" r = expresion(false) "]")?
	{
	  try {
	    if(r == null) {
	       //System.out.println("Voy a introduxir un parametro" + simbolo_accion.getNombre() +" "+ id1.image);
	    	//introducimos el parametro actual en la tabla de simbolos
	    	param2 = tabla_simbolos.introducir_parametro(id2.image,tipo, clase, nivel,dir);
			dir+= param2.get_tamanyo();
	    	//Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
	    	simbolo_accion.addParametro(param2);
	    	//System.out.println("Aï¿½adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
	    }else{
	      	//Caso vector
	      	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
	      	  	//El vector esta bien definido
	      	  	Simbolo.Tipo_variable tipo_aux = null;
	      	  	if(tipo == Simbolo.Tipo_variable.ENTERO) {
	            	tipo_aux = Simbolo.Tipo_variable.VECENT;
	          	}else if(tipo == Simbolo.Tipo_variable.CHAR) {
	            	tipo_aux = Simbolo.Tipo_variable.VECCHAR;
	          	}else {
	            	tipo_aux = Simbolo.Tipo_variable.VECBOOL;
	          	}
	      	  	param2 = tabla_simbolos.introducir_parametro_vector(id2.image, tipo_aux, clase, r.valorEnt, nivel, dir);
	      	  	dir+= param2.get_tamanyo();
	      	  	simbolo_accion.addParametro(param2);
	      	}else {
	      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
	      	  	//System.out.println("Error semantico: No se puede declarar un vector sin una constante entera. En la linea " + id2.beginLine + " y la columna " + id2.beginColumn);
	      	}
	      	
	      	 
	    }
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("Error  semantico");
	  }
	}
	)*)
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros");
  }
}

Simbolo.Clase_parametro clase_parametros():
{
}
{ try {
	(< tVAL > {return Simbolo.Clase_parametro.VAL; }
	| < tREF >){return Simbolo.Clase_parametro.REF; }
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la clase de parametros");
  }
}

void bloque_sentencias(Simbolo s, String etACC):
{
  //Lista necesaria para recuperar los parametros en la invicacion de la accion
  ArrayList<Simbolo> lista_param = new ArrayList<Simbolo>();
}
{ try {
  	{
  	  System.out.println("Entro a bloque sentencias");
  	  //Generamos nueva etiqueta para el comienzo de las acciones de la accion
  	  
  	  
	  //Es una accion hay una etiqueta para saber donde empiezan las intrucciones de la accion
  	  if(!s.ES_PROGRAMA()) {
  	    pw.println(";Accion " + s.getNombre());
  	    pw.println(etACC+":");
  	  }

	  //Obtenemos los parametros de la accion
  	  lista_param = s.getListaParametros();
  	  //Recorremos la lista de forma inversa porque los parametros estan apilados al reves
  	  Simbolo p = new Simbolo();
  	  if(lista_param!= null) { 
	  	  for (int j = lista_param.size() - 1; j >= 0; j--)
	      {
	         p = lista_param.get(j);
	         pw.println("; rec. parametro " + p.getNombre() + " de tipo " + p.getVariable().toString() + 
	         " pasado por " + p.getParametro().toString());
	         pw.println("\t SRF   " + (nivel - p.getNivel()) + "  " + p.getDir());
	         pw.println("\t ASGI");
	      }
	  }

  	}
	(< tPRINCIPIO > lista_sentencias() < tFIN >)
	{
	  //tabla_simbolos.imprimirTabla();
	 }
  } catch (ParseException e) {
//    System.out.println("1");
    
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el bloque de sentencias");
  }
}
void lista_sentencias():
{
}
{ 
	sentencia()(sentencia())*
}

void sentencia():
{
  Token id = null;
  boolean esVector = false;
  Simbolo simbolo_id = null;
  Simbolo s = null;
  Simbolo.Tipo_variable tpID = null;
  RegistroExpr r = null;
  boolean accesoComponente = false;
}
{
 (leer() ";"
 | escribir() ";"
 | (id = < tID >
 {
   		System.out.println("SE entra a sentencia "+ id.image);
 		simbolo_id = tabla_simbolos.buscar_simbolo(id.image);
 		if(simbolo_id.ES_VARIABLE() || simbolo_id.ES_PARAMETRO()) {
 		    System.out.println("Es una variable");
	   	  	if(simbolo_id == null) {
	     		//System.out.println("Error semantico, no existe el simbolo con nombre: " + id.image +" en la tabla de simbolos. En la linea " + iinLine + " y la columna " + id.beginColumn);
	     		tpID = Simbolo.Tipo_variable.DESCONOCIDO;
		   	}
		  	else if(simbolo_id.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && simbolo_id.getParametro() == Simbolo.Clase_parametro.VAL) {
				 //System.out.println("Error semantico, no se puede asignar un valor a un parametro por valor. En la linea " + id.beginLine + " y la columna " + id.beginColumn);
				 //TODO: Mirar si esto tiene que ir aqui o en asignacion, y si se tiene que poner el tpId a desconocido para seguir la ejecucuion
				 tpID = Simbolo.Tipo_variable.DESCONOCIDO;
		   	}else {
		     	tpID = simbolo_id.getVariable();
	  		}
	
	  		//MIRAR si hay que unificar if 		
			if(simbolo_id.ES_VECTOR()) {
		        pw.println(";Inicial vector");
		        pw.println("	SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
		        System.out.println("VECTOOOOOOOOOOOOOOOOOOOOOOOOOOOOOr");
	        
		     }else { 
			      pw.println("; Direccion de la variable " + simbolo_id.getNombre());
			      pw.println("	SRF   " + (nivel - simbolo_id.getNivel()) + "  " + simbolo_id.getDir());
			 }
		}	
   
 }
 ("["r = expresion(true)"]")?
 {
   //Si es el vector entero
		
   		if(simbolo_id.ES_VARIABLE() || simbolo_id.ES_PARAMETRO()) { 
	        if(r == null) {
	            //Aqui ya se empieza a asignar la primera componente
	            pw.println(";Asignacion componente 1");
	          	System.out.println("Se va a asignar una variable nombre: "+ id.image + " tipo: " + simbolo_id.getVariable());
	          	accesoComponente = false;
	        }else{
	            accesoComponente = true;
	          	System.out.println("Acceso a componente del vector aa");
	    	  	if(r.valorEnt > simbolo_id.getLongitud()) {
	    	  	 	 //TODO: excepciones, la componente solicitada esta fuera de rango
//	    	  	  	System.out.println("Error semantico: Acceso componente fuera de rango. En la linea " + id.beginLine + " y la columna " + id.beginColumn);
	    		}
	    		pw.println("	PLUS   ");
		    }
	
	   		esVector = true;
	  }
 }
 )(asignacion(simbolo_id,r,tpID,accesoComponente)|invocacion_accion(simbolo_id,tpID))
 |seleccion ()
 | mientras_que())
}

void leer():
{
}
{ try {
  <tLEER> {pw.println("; Lectura"); }
  "(" lista_asignables() ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al leer");
  }
}


void lista_asignables():
{
  Token t1 = new Token();
  Token t2 = new Token();
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
  boolean esComponente = false;
  RegistroExpr r = null;
}
{ try {
  t1 = <tID>
  {
    esComponente = false;
    r = null;
  }
  ("[" r = expresion(false) "]"
  {
	esComponente = true;
  }
  )?
  {
    //Obtenemos el simbolo con el nombre del id
    s1 = tabla_simbolos.buscar_simbolo(t1.image);
    if(s1 == null){
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(s1.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s1.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
  		System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
  	}else if(s1.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s1.getParametro() == Simbolo.Clase_parametro.VAL){
  	    System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
  	}else if(s1.ES_VARIABLE()){
  	  //Obtenemos la variable
  	    if(s1.ES_VECTOR() && !esComponente) {
  	      //Es un vector entero hay que ir componente por componente leyendo
  	      pw.println("; Leer variable " + s1.getNombre());
  	      int offset = 0;
  	      int bytes_componente = s1.get_tamanyo_componente();
  	      for(int i = 0; i < s1.getLongitud(); i++) {
	  	       	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + (s1.getDir()+offset));
	  	       	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
  	      }
  	    }else {
  	      	//Es o una variable normal o una componente de un vector
  	      	if(esComponente) {
  	      	  	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
		      	  	int offset = (r.valorEnt - 1) * s1.get_tamanyo_componente();
		          	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir()+offset);
		          	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
			    		pw.println("\t RD    1");
			  	  	}
			  	  	else{
			  	  		pw.println("\t RD    0");
			  		}
		      	}else {
		      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
		      	  	System.out.println("No se puede declarar un vector sin una constante entera");
		      	}

  	      	}else { 
		  	  	pw.println("; Leer variable " + s1.getNombre());
		      	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
		      	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	  		}
  		}
  	}else if(s1.ES_REFERENCIA()) {
  	     pw.println("; Leer parametro por referencia " + s1.getNombre());
  	     if(s1.ES_VECTOR() && !esComponente) {
  	      //Es un vector entero hay que ir componente por componente leyendo
  	      pw.println("; Leer variable " + s1.getNombre());
  	      int offset = 0;
  	      int bytes_componente = s1.get_tamanyo_componente();
  	      for(int i = 0; i < s1.getLongitud(); i++) {
	  	       	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + (s1.getDir()+offset));
	  	       	pw.println("\t DRF");
	  	       	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
  	      }
  	    }else {
  	      	//Es o una variable normal o una componente de un vector
  	      	if(esComponente) {
  	      	  	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
		      	  	int offset = (r.valorEnt - 1) * s1.get_tamanyo_componente();
		          	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + (s1.getDir()+offset));
		          	pw.println("\t DRF");
		          	if (s1.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
			    		pw.println("\t RD    1");
			  	  	}
			  	  	else{
			  	  		pw.println("\t RD    0");
			  		}
		      	}else {
		      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
		      	  	System.out.println("No se puede declarar un vector sin una constante entera");
		      	}

  	      	}else { 
		  	  	pw.println("; Leer variable " + s1.getNombre());
		      	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
		      	pw.println("\t DRF");
		      	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	  		}
  		}
  } }
  ( "," t2 = <tID>{
    r = null;
    esComponente = false;
  }
  ("[" r = expresion(false) "]"
  {
		esComponente = true;
  }
  )?
  {
	//Obtenemos el simbolo con el nombre del id
    s2 = tabla_simbolos.buscar_simbolo(t2.image);
    if(s2 == null){
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(s2.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s2.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
  		System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
  	}else if(s2.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s2.getParametro() == Simbolo.Clase_parametro.VAL){
  	    System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
  	}else if(s2.ES_VARIABLE()){
  	  //Obtenemos la variable
  	    if(s2.ES_VECTOR() && !esComponente) {
  	      //Es un vector entero hay que ir componente por componente leyendo
  	      pw.println("; Leer variable " + s2.getNombre());
  	      int offset = 0;
  	      int bytes_componente = s2.get_tamanyo_componente();
  	      for(int i = 0; i < s2.getLongitud(); i++) {
	  	       	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + (s2.getDir()+offset));
	  	       	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
  	      }
  	    }else {
  	      	//Es o una variable normal o una componente de un vector
  	      	if(esComponente) {
  	      	  	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
		      	  	int offset = (r.valorEnt - 1) * s2.get_tamanyo_componente();
		          	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + (s2.getDir()+offset));
		          	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
			    		pw.println("\t RD    1");
			  	  	}
			  	  	else{
			  	  		pw.println("\t RD    0");
			  		}
		      	}else {
		      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
		      	  	System.out.println("No se puede declarar un vector sin una constante entera");
		      	}

  	      	}else { 
		  	  	pw.println("; Leer variable " + s2.getNombre());
		      	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
		      	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	  		}
  		}
  	}else if(s2.ES_REFERENCIA()) {
  	     pw.println("; Leer parametro por referencia " + s2.getNombre());
  	     if(s2.ES_VECTOR() && !esComponente) {
  	      //Es un vector entero hay que ir componente por componente leyendo
  	      pw.println("; Leer variable " + s2.getNombre());
  	      int offset = 0;
  	      int bytes_componente = s2.get_tamanyo_componente();
  	      for(int i = 0; i < s2.getLongitud(); i++) {
	  	       	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir()+offset);
	  	       	pw.println("\t DRF");
	  	       	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
		  		offset+=bytes_componente;
  	      }
  	    }else {
  	      	//Es o una variable normal o una componente de un vector
  	      	if(esComponente) {
  	      	  	if(!r.esVariable && r.tipo == Simbolo.Tipo_variable.ENTERO) {
		      	  	int offset = (r.valorEnt - 1) * s2.get_tamanyo_componente();
		          	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir()+offset);
		          	pw.println("\t DRF");
		          	if (s2.getTipoComponente() == Simbolo.Tipo_variable.ENTERO){ 
			    		pw.println("\t RD    1");
			  	  	}
			  	  	else{
			  	  		pw.println("\t RD    0");
			  		}
		      	}else {
		      	  	//TODO: gestionar excepciones, no se puede declarar un vector sin una constante entera
		      	  	System.out.println("No se puede declarar un vector sin una constante entera");
		      	}

  	      	}else { 
		  	  	pw.println("; Leer variable " + s2.getNombre());
		      	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
		      	pw.println("\t DRF");
		      	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
		    		pw.println("\t RD    1");
		  	  	}
		  	  	else{
		  	  		pw.println("\t RD    0");
		  		}
	  		}
  		}
  }
  }

  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de asignables");
  }
}

void escribir():
{
}
{ try {
  <tESCRIBIR> { pw.println("; Escritura");}
  "(" lista_escribibles() ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al escribir");
  }
}


void lista_escribibles():
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  
}
{ try {
  r1 = expresion(true)
  {
    System.out.println("Tipo dentro de escribir " + r1.tipo);
    if(r1.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
       	System.out.println("No se puede escribir un tipo desconocido");
    }else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		//TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r1.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra

      	for (int x=1;x<r1.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r1.cadena.charAt(x));
	   		pw.println("	WRT		0");
	  	}
	}
	
	else if (r1.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r1.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}else if(r1.sim.ES_VECTOR()) {
	  		if(r1.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
	  		  	pw.println("	WRT		1");
	  		}else {
	  		 	pw.println("	WRT		0"); 
	  		}
	  		int bytes_componente = r1.sim.get_tamanyo_componente();
	  		int offset = r1.sim.get_tamanyo_componente();
	  		for(int i = 1; i <r1.tam_vec; i++) {
				 pw.println(";Escritura variablea la variable " + r1.sim.getNombre());
       	 		pw.println("	SRF	"+  (nivel - r1.sim.getNivel()) + "	" + (r1.sim.getDir() + offset));
       	 		pw.println("	DRF");
       	 		if(r1.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
		  		  	pw.println("	WRT		1");
		  		}else {
		  		 	pw.println("	WRT		0"); 
		  		}
		  		offset+= bytes_componente;
	  		}
	}
  }
  (","r2 = expresion(true)
  {
	   if(r2.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
	       System.out.println("No se puede escribir un tipo desconocido");
	   }else if(r2.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		//TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r2.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra
      	
      	for (int x=1;x<r2.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r2.cadena.charAt(x));  
	   		pw.println("	WRT		0");
	   	}
	}
	
	else if (r2.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r2.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}else if(r1.sim.ES_VECTOR()) {
	  		if(r2.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
	  		  	pw.println("	WRT		1");
	  		}else {
	  		 	pw.println("	WRT		0"); 
	  		}
	  		int bytes_componente = r2.sim.get_tamanyo_componente();
	  		int offset = r2.sim.get_tamanyo_componente();
	  		for(int i = 1; i <r2.tam_vec; i++) {
				 pw.println(";Escritura variablea la variable " + r2.sim.getNombre());
       	 		pw.println("	SRF	"+  (nivel - r2.sim.getNivel()) + "	" + (r2.sim.getDir() + offset));
       	 		pw.println("	DRF");
       	 		if(r2.sim.getTipoComponente() == Simbolo.Tipo_variable.ENTERO) {
		  		  	pw.println("	WRT		1");
		  		}else {
		  		 	pw.println("	WRT		0"); 
		  		}
		  		offset+= bytes_componente;
	  		}
	}
  }
  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de escribibles");
  }
}

void invocacion_accion(Simbolo id, Simbolo.Tipo_variable tpID):
{
  ArrayList<Simbolo > parametros_necesarios = id.getListaParametros();
  System.out.println("Se va a invocar una accion cuyos parametros son: "+ parametros_necesarios.toString());
}
{ try {
  argumentos(id,tpID,parametros_necesarios) ";"
  {
     pw.println("; Invocando a " + id.getNombre().toUpperCase());
     pw.println("\t OSF   " + (id.getDir() - 1) + "  " + (nivel - id.getNivel())+ " " + id.getEtiqueta());
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la invocacion de acciones");
  }
}

void asignacion(Simbolo id, RegistroExpr r, Simbolo.Tipo_variable tpID,boolean ac):
{
  RegistroExpr r1 = new RegistroExpr();
  Simbolo.Tipo_variable tpExp;
  Token t;
  boolean accesoComponente = false;
}
{ try {
  {
    if(id.ES_ACCION()){
    	//TODO: excepciones
    }else if(id.ES_REFERENCIA()) {
      	pw.println("; Direccion del parametro por referencia " + id.getNombre());
        pw.println("	SRF   " + (nivel - id.getNivel()) + "  " + id.getDir());
        pw.println("	DRF");
    }else {
		//TODO: este else no se si hace falta
    }
  }
  t = <tOPAS> r1 = expresion(true)
  {
	    System.out.println("OPAS");
	    if(r1.tipo == Simbolo.Tipo_variable.ENTERO) {
			System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorEnt);
	  	}else if(r1.tipo == Simbolo.Tipo_variable.CHAR) {
	  	  	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorChar);
	  	}else if(r1.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
	  	  	System.out.println("Se va a asignar un " + r1.tipo.toString());
	  	}else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) {
	  	 	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorBool);
	  	}else if(r1.tipo == Simbolo.Tipo_variable.CADENA) {
	  	  	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.cadena);
	  	}
	
	    //Hay que mirar que los tipos sean asignables y que coincidan ambos tipos
	    System.out.println("AccesoComponente: " + ac);
	    if(ac && r1.tipo != id.getTipoComponente()) {
	        //TODO: excepcion no coincide tipo, componente del vector
//	    	System.out.println("Error semantico: Acceso componente true y no coinciden tipos. En la linea " + id.beginLine + " y la columna " + id.beginColumn);
	    	ac = false;
	  	}else if(ac && r1.tipo == id.getTipoComponente()) {
	  	  	pw.println("	ASG");
	    	//TODO: mirar si hay que hacer algoe special
	    	ac = false;
	    }else if(id.getVariable() != r1.tipo && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
	  		//TODO: excepciones
//	      	System.out.println("Error semantico: No se puede asignar porque los tipos no coinciden " + id.getVariable().toString()+" " + id.getNombre() + " " + r1.tipo.toString() + " .En la linea " + id.beginLine + " y la columna " + id.beginColumn);
	   	}else if( r1.tipo == Simbolo.Tipo_variable.CADENA) {
	   		//TODO: excepciones
	   		//Caso especial las cadenas solo sirven en escribirss
//	      	System.out.println("Error semantico: No se pueden asignar las cadenas, solo para escritura .En la linea " + id.beginLine + " y la columna " + id.beginColumn);
	   	}else if(id.ES_VECTOR()) {
			if(id.getLongitud() != r1.tam_vec) {
				//TODO: excepciones no coinciden en tama�o no se puede asignar
//				System.out.println("Error semantico: Los vectores NO coinciden en tamanyo. En la linea " + id.beginLine + " y la columna " + id.beginColumn);
			}else {
				System.out.println("Los vectores SI coinciden en tamanyo");
				
				int bytes_componente = id.get_tamanyo_componente();
				int offset = bytes_componente;
				pw.println("	ASG");
				for(int i = 1; i < r1.tam_vec; i++) {
				  	pw.println(";Asignacion componente "+ (i+1));
				  	pw.println("	SRF   " + (nivel - id.getNivel()) + "  " + (id.getDir()+offset));
					pw.println("	SRF   " + (nivel - r1.sim.getNivel()) + "  " + (r1.sim.getDir()+offset));
        			pw.println("	DRF");
        			pw.println("	ASG");
        			offset+=bytes_componente;
				}
			}
	   	}else { 
			//Si todo va bien hacemos la asignacion
		   	pw.println("; Asignacion.");
		    pw.println("	ASG");
	    	System.out.println("salgo");
	  }
	
  }
  ";"
  } catch (ParseException e) {
     SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en asignacion");
  }
}


void mientras_que():
{
   RegistroExpr r = new RegistroExpr();
}
{ try {
  <tMQ>
  {
    
    String etMQ = et.nueva_et();
    pw.println(";MQ");
    pw.println(etMQ + ":");
  }
  r = expresion(true)
  {
       Token t = getToken(0);
       String etFIN = et.nueva_et();
       pw.println("	JMF	" + etFIN);
  	   if(r.tipo != Simbolo.Tipo_variable.BOOLEANO) {
		//TODO: gestionar excepciones
//		System.out.println("Error seantico: La condicion del mientras que no es un booleano. En la linea " + t.beginLine + " y la columna " + t.beginColumn);
    }
  }
  lista_sentencias() <tFMQ>
  {
     
     pw.println("	JMP	" + etMQ);
     pw.println(";FMQ");
     pw.println(etFIN + ":");
     
    
  }
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en mientras que");
  }
}

void seleccion():
{
   RegistroExpr r = new RegistroExpr();
  
}
{ try {
  <tSI> {pw.println(";SI" );}
  r = expresion(true)
  {
    
    String etiqSINO = et.nueva_et();
    //TODO: mirar etiqueta sino si no hay sino
    pw.println("	JMF " + etiqSINO);
    Token t = getToken(0);
    if(r.tipo == Simbolo.Tipo_variable.BOOLEANO && !r.esVariable){
      //TODO mirar este if si hay que ejecutarlo
     	if(r.valorBool) {
     	 	System.out.println("Este codigo siempre se va a ejecutar porque es una constante TRUE");
     	}else {
			System.out.println("Este codigo nunca se va a ejecutar porque es una constante FALSE");	
     	}
        
    }else if(r.tipo != Simbolo.Tipo_variable.BOOLEANO ) {
		//TODO: gestionar excepciones
//		System.out.println("Error semantico: La condicion de la seleccion no es un booleano. En la linea " + t.beginLine + " y la columna " + t.beginColumn);
    }
  }
  <tENT> { pw.println(";ENT" );}
  lista_sentencias()
  {
    
    String etiqFIN= et.nueva_et();
    pw.println("	JMP " + etiqFIN);
    pw.println(etiqSINO +":" );
  }
  ( <tSI_NO>
  {
    
    pw.println(";SI_NO" );
  }
  lista_sentencias() )? <tFSI>
  {
    pw.println(etiqFIN +":" );
    pw.println(";FSI" );
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en seleccion");
  }
}

void argumentos(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params;
}
{ try {
 ("(" (params = lista_expresiones(id,tpID,parametros_necesarios)
 {
    //TODO: pruebas con distintas funciones
   	if(params.size() != parametros_necesarios.size()) {
   	  	//TODO: gestionar excepciones 
		System.out.println("Error semantico: Los parametros patra invocar a la accion no coinciden "+ params.size() + " , " + parametros_necesarios.size());
   	}else {
   	  	System.out.println("Los parametros para invocar a la accion coinciden "+ params.size() + " , " + parametros_necesarios.size());
   	  	Simbolo s = new Simbolo();
   	  	RegistroExpr r = new RegistroExpr();
   	  	int num_params = params.size();
   	  	//TODO: mirar si hay que hacer alguna comprobacion mas, por ejemplo DESCONOCIDO
   	  	for( int i = 0; i < num_params; i++) {
			s = parametros_necesarios.get(i);
			r = params.get(i);
			tabla_simbolos.imprimirTabla();
			System.out.println("Parametro numero " + i + " tipo_necesario: "+ s.getVariable().toString() + " tipo_pasado: " + r.tipo.toString());
			if(s.getVariable() != r.tipo) {
				//TODO: gestionar excepciones
				System.out.println("Error semantico: Los tipos de los argumentos no coinciden");
			}else if(s.getParametro() == Simbolo.Clase_parametro.REF && !r.esVariable) {
			  	//TODO: gestionar excepciones
			  	System.out.println("Error semantico: Se esperaba un parametro por referecncia, no por valor");
			}
			}
   	  	}
   	}

  )? ")")?
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en argumentos");
  }
}


//TODO: Hacer un programa para probar esto, devuelve una lista de RegistroExpresiones
//TODO: igual no hace falta pasar tantos parametros hasta esta funcion
ArrayList<RegistroExpr> lista_expresiones(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params = new ArrayList<RegistroExpr>();
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  
}
{ try {
  r1 = expresion(true)
  {
    params.add(r1);
  }
  ( "," r2 = expresion(true)
  {
    params.add(r2);
  }
  )*
 {
   return params;
 }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de expresiones");
  }
}


Token operador_multiplicativo():
{
  Token t;
}
{ try {
  ( t = <tMUL>{return t;}
  | t = <tAND>{return t;}
  | t = <tDIV>{return t;}
  | t = <tMOD>{return t;}
  )
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador multiplicativo");
  }
}

Token operador_aditivo():
{
  Token t;
}
{ try {
  ( t = <tMAS>{return t;}
  | t = <tMENOS>{return t;}
  | t = <tOR>{return t;}
  )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador aditivo");
  }
}

Token operador_relacional():
{
  Token t;
}
{ try {
  ( t = <tMAYOR>{return t;}
  | t = <tMENOR>{return t;}
  | t = <tIGUAL>{return t;}
  | t = <tMAI>{return t;}
  | t = <tMEI>{return t;}
  | t = <tNI>{return t;}
   )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador relacional");
  }
}

//TODO: hacer que se pueda hacer mayor menor de caracteres, cadenas, etc??
RegistroExpr expresion(boolean vec):
{ 
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  	r1 = expresion_simple(vec)
  	{
  	  //System.out.println("El tipo de r1 es: " + r1.tipo.toString());
	  result = r1;
  	}
  	( t = operador_relacional() r2 = expresion_simple(vec) 
  	{
  	  boolean ok = true;
 
	  String operacion = t.image;
//	  if(operacion != null) { 
		  switch(operacion) { 
		  		case ">":
		  			pw.println("	GT");
		  			//System.out.println("Detectado >");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede >");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede >");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt > r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<":
		  			pw.println("	LT");
		  			//System.out.println("Detectado <");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt < r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case ">=":
		  			pw.println("	GTE");
		  			//System.out.println("Detectado >=");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede >=");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede >=");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt >= r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<=":
		  			pw.println("	LTE");
		  			//System.out.println("Detectado <=");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <=");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <=");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt <= r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		//TODO: mirar el < > y en = si se puede hacer con booleanos, cadenas, caracteres
		  		case "=":
		  			pw.println("	EQ");
		  			//System.out.println("Detectado =");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede =");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede =");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt == r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<>":
		  			pw.println("	NEQ");
		  			//System.out.println("Detectado <>");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <>");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <>");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt != r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }
  	}
  	)* {
  	  //System.out.println("Voy a devolver result:" + result.tipo);
  	  return result;
  	  }
}

RegistroExpr expresion_simple(boolean vec):
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
	r1 = termino(vec) {
	  //System.out.println("primero");
      result = r1;
	  
	}(t = operador_aditivo() r2 = termino(vec)
	{

	 
	  boolean ok = true;
	  String operacion = t.image;
		  switch(operacion.toLowerCase()) { 
		  		case "+":
		  			pw.println("	PLUS");
		  			//System.out.println("Detectado +");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede sumar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede sumar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt + r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "-":
		  			pw.println("	SBT");
		  			//System.out.println("Detectado -");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede restar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede restar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobacionesde modulo por 0
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt - r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
	  				//return result;
					break;
		  		case "or":
		  			pw.println("	OR");
		  			//System.out.println("Detectado and");
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer or");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es booleano o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer or");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorBool | r2.valorBool; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }

	}
	)*
	{
	  //System.out.println("Voy a devolver result:" + result.tipo);
	  return result;
	}
}


RegistroExpr termino(boolean vec):
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  RegistroExpr ant = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  
  r1 = factor(vec)
  {
    //System.out.println("primero");
    //Si solo es un valor devolvemos ese valor solo
    result = r1;
    ant = r1;
  }

  ( t = operador_multiplicativo() r2 = factor(vec)
  { 
	  boolean ok = true;
	  //System.out.println("segundo");
	  String operacion = t.image;
  		  //Hay que hacer lowercase porque aunque el analizador sea case insensitive, el switch reconoce la diferencia entre mayusculas y minusculas
		  switch(operacion.toLowerCase()) { 
		  		case "*":
		  			pw.println("	TMS");
		  			//System.out.println("Detectado *");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede multiplicar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede multiplicar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				    System.out.println("Voy a multiplicar: " + result.valorEnt + " y " + r2.valorEnt);
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt * r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt * r2.valorEnt;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "mod":
		  			pw.println("	MOD");
		  			//System.out.println("Detectado mod");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede hacer mod");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede hacer mod");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  			  //Mirar si esto va bien
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				    if(!r2.esVariable) {
		  				      	System.out.println("Voy a mod de constante: " + result.valorEnt + " y " + r2.valorEnt);
		  				      	if(r2.valorEnt == 0) {
		  				      	  	//TODO: Gestionar excepciones de modulo 0
//		  				      	  	System.out.println("Error semantico: Es modulo 0. En la linea " + t.beginLine + " y la columna " + t.beginColumn);
		  				      	}else {
		  				      	  	result.valorEnt =	result.valorEnt % r2.valorEnt;
		  				      	}
		  					}else {
		  					  	//TODO: Mirar que hay que hacer aqui
//		  					    System.out.println("regexpr "+r2.esVariable);
//		  					  	result.tipo =  Simbolo.Tipo_variable.ENTERO;
//		  						result.valorEnt =	result.valorEnt % r2.valorEnt;
		  					}
		  				  	
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
					break;
		  		case "div":
		  			pw.println("	DIV");
		  			System.out.println("Detectado /");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede dividir");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede dividir");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de division por 0
		  				  	System.out.println("Voy a dividir: " + result.valorEnt + " y " + r2.valorEnt);
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt / r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt / r2.valorEnt;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "and":
		  			pw.println("	AND");
		  			//System.out.println("Detectado and");
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer and");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer and");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							System.out.println("Voy a and: " + result.valorBool + " y " + r2.valorBool);
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorBool && r2.valorBool;
		  					System.out.println("salgo de and");
//		  					ant.valorBool = r1.valorBool && r2.valorBool; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  			
		  }
  }
  )*
  {
    //System.out.println("Voy a devolver result:" + result.tipo);
    return result;
  }
  
}

/*("-" factor()
	| <tNOT> factor()
	| "(" expresion() ")"
	| <tENTACAR> "(" expresion() ")"
	| <tCARAENT> "(" expresion() ")"
	| <tID>
	| <tNUM>
	| <tCAR>
	| <tCADENA>
	| <tTRUE>| <tFALSE>)*/

RegistroExpr factor(boolean vec):
{
  RegistroExpr re = null;
  Token t;
  Simbolo s;
}
{
  ("-" re = factor(vec)
  {
    pw.println("	NGBI");
    if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			System.out.println("El tipo de la variable no es compatible con \"-\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.ENTERO) {
		re.valorEnt = -re.valorEnt;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }
  
  | <tNOT> re = factor(vec)
  {
    pw.println("	NGB");
    if(re.tipo != Simbolo.Tipo_variable.BOOLEANO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			System.out.println("El tipo de la variable no es compatible con \"NOT\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.BOOLEANO) {
		re.valorBool = !re.valorBool;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }

  //TODO: descomentar esto cuando ya vaya expresion
  | "(" re = expresion(true) ")"
  {
    //Si solo hay parentesis hay que devolver lo que hay dentro de los parentesis
    return re;
  }

  
  | t = <tENTACAR> "(" re =expresion(true) ")"
  {
  	if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.CHAR;
		new_r.valorChar = (char)re.valorEnt;
		return new_r;
    }
    
    
    
  }
  | <tCARAENT> "(" re = expresion(true) ")"
  {
    if(re.tipo != Simbolo.Tipo_variable.CHAR && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.ENTERO;
		new_r.valorEnt = (int)re.valorChar;
		return new_r;
    }
    
  }
  //TODO: vector
  | t = <tID>("["re = expresion(false)"]")?
  {
     System.out.println("He encontrado un id");
     s = tabla_simbolos.buscar_simbolo(t.image);
     if(s == null) {
//       	 System.out.println("Error semantico: No he encontrado simbolo. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
     	//TODO: no existe el simbolo hay que lanzar una exepcion
     }else if(s.ES_ACCION()) {
//        System.out.println("Error semantico: He encontrado una accion. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
     	//TODO: no existe el simbolo hay que lanzar una exepcion
     }else if(s.ES_VECTOR()) {
        System.out.println("He encontrado un vector");
     	if(re != null) {
     	  	System.out.println("eteteyyeyeyeyyeye");
     		//Es una componente del vector
     	   	if(re.esVariable) {
	 			//otras cosas
 		   	}else {
 		     	//Caso es una constante
 		     	if(re.tipo != Simbolo.Tipo_variable.ENTERO) {
// 		       		System.out.println("Error semantico: Se ha detectado una varieable vector y no es constante entera. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
 		       		//TODO: expeciones tiene que ser una constante entera
 		     	}else {
 		        	if(re.valorEnt <= 0) {
// 		          		System.out.println("Error semantico: Se ha detectado una variable vector y no es positivo. En la linea "+ t.beginLine + " y la columna " + t.beginColumn);
 		          		//TODO: excepciones tiene que ser una constante positiva
 		        	}else if(re.valorEnt > s.getLongitud()){
 		        	  System.out.println("Overflow vectores");
 		          		//TODO: Excepcion overflow indexacion
 		        	  
 		        	}else {
 		          		System.out.println("aaSe ha detectado una varieable vector llamada: " + t.image +" y de tam: "+re.valorEnt + " y se puede declarar");
 		          		//Se puede declarar el vector
 		          		Simbolo.Tipo_variable tipo_aux = s.getTipoComponente();
 		          		re.tipo = tipo_aux;
					    re.s = s.getTipo();
					    re.esVariable = true;
					    re.sim = s;
 		          		pw.println("; Acceso a la variable " + s.getNombre() + "[" + re.valorEnt+ "]");
				       	pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.calcularDesplazamientoDireccion(re.valorEnt -1));
				       	pw.println("	DRF");
					    
					    return re;
		       		}
     			}
     		}
     	}else {
     	  	System.out.println("He encontrado vector entero");
     	  	re = new  RegistroExpr();
 			re.tipo = s.getVariable();
     	  	//Es un vector entero
     		re.tam_vec = s.getLongitud();
     		re.s = s.getTipo();
		    re.esVariable = true;
		    re.sim = s;
		    pw.println("; Acceso a la variable " + s.getNombre());
       	 	pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.getDir());
       		pw.println("	DRF");
		    return re;
     	}
     }else {
       	 re = new  RegistroExpr();
	     pw.println("; Acceso a la variable " + s.getNombre());
       	 pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.getDir());
       	 pw.println("	DRF");
	     re.tipo = s.getVariable();
	     re.s = s.getTipo();
	     re.esVariable = true;
	     re.sim = s;
	     return re;
	}
     
  }
  | t  = <tNUM>
  {
     if(vec)pw.println("	STC   " + t.image);
     System.out.println("Hay una const entera");
     
     return RegistroExpr.ENTERO(t.image);
  }
  | t = <tCAR>
  {
     pw.println("	STC   " + t.image);
     return RegistroExpr.CHAR(t.image);
  }
	
  | t = <tCADENA>
  {
     pw.println(";cadena	" + t.image);
     return RegistroExpr.CADENA(t.image);
  }
  | <tTRUE>
  {
     pw.println("	STC   1" );
     return RegistroExpr.BOOL(true);
  }
  | t = <tFALSE>)
  {
     pw.println("	STC   0" );
     return RegistroExpr.BOOL(false);
  }
}

