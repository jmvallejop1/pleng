/**
 * Especificación JavaCC para la Práctica 2 (Procesadores de Lenguajes)
 * Javier Fabra - jfabra@unizar.es
 * v1.2 - 2021/03/08
 */
options
{
  static = true;
  //hacemos el leguaje case insenstive, ignoramos la diferencia entre mayusculas y minusculas.
  ignore_case = true;
}

PARSER_BEGIN(MiniLengCompiler)
package compiler;
import java.io.*;
import semantico.*;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.PrintWriter;


public class MiniLengCompiler
{


  public static class RegistroExpr {
	int valorEnt;
	boolean valorBool;
	char valorChar;
	boolean esVariable = false;
	String cadena;
	Simbolo.Tipo_variable tipo;
	Simbolo.Tipo_simbolo s;

	//Devuelve un Registro expresion booleano 
	public static RegistroExpr BOOL(boolean b) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.BOOLEANO;
		reg.valorBool = b;
		return reg;
	}
	//Devuelve un Registro de tipo Entero
	public static RegistroExpr ENTERO(String entero) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.ENTERO;
		reg.valorEnt = Integer.parseInt(entero);
		return reg;
	}
	//Devuelve un Registro de tipo Char
	public static RegistroExpr CHAR(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CHAR;
		reg.valorChar = c.charAt(0);
		return reg;
	}
	
	//Devuelve un Registro de tipo cadena
	public static RegistroExpr CADENA(String c) {
		RegistroExpr reg = new RegistroExpr();
		reg.tipo= Simbolo.Tipo_variable.CADENA;
		reg.cadena = c;
		return reg;
	}
	
//	//Devuelve un Registro de tipo desconocido
//	public static RegistroExpr DESCONOCIDO() {
//		RegistroExpr reg = new RegistroExpr();
//		reg.tipo = Simbolo.Tipo_variable.DESCONOCIDO;
//		reg.variable = true;
//		return reg;
//	}
//	
	}

  public static Etiqueta et = new Etiqueta();
  //Declaracion print writer para escribir el fichero .code
  public static PrintWriter pw;
	
  //Declaraciones necesarias para tablla de simbolos
  static int nivel = 0;
  static final int INICIAL = 3;

  //Inicializacion de la direccion para a�adir a la tabla de simbolos
  
  public static int dir = INICIAL;
  static TablaSimbolos tabla_simbolos = new TablaSimbolos();
  public static void main(String args []) throws ParseException
  {
    //Pasamos como parametro el fichero que queremos compilar
    //Intentamos leer el fichero 
    try {
      	  System.out.println(args[0]);
	      FileInputStream F = new FileInputStream(args[0]);
	      System.setIn(F);
	}catch (Exception e) {
	   //Si no encuentra fichero lee de la entrada estandar
	    System.out.println("Leyendo de la entrada estandar...");
    }
    
   
	 try {
	   		 //TODO: camviar esto por el nombre del fichero + code
	   		 File cod_inter = new File("C:\\Users\\Jmval\\OneDrive\\Escritorio\\pleng\\p2\\codigo_intermedio\\pruebas.code");
    		 FileWriter fichero_salida = new FileWriter(cod_inter);
   			 pw = new PrintWriter(fichero_salida);
	         MiniLengCompiler parser = new MiniLengCompiler(System.in);
	   		 tabla_simbolos.inicializar_tabla();
	   		 MiniLengCompiler.programa();
	  }catch (TokenMgrError e) {
	      try {
	           //gestion de los errores lexicos
		       int linea = SimpleCharStream.getBeginLine();
		       int columna = SimpleCharStream.getBeginColumn();
		       char c = SimpleCharStream.readChar();
	           LexicalErrorManager.printLexicalError(linea,columna,c);
	      }catch(Exception ex){}  
		}
		//TODO:gestionar excepcion del print writer
		catch (IOException e) { }
 	 }
}

PARSER_END(MiniLengCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "%" : COMENTARIO
| "%%": COMENTARIO_MULTILINEA
}

< COMENTARIO_MULTILINEA> SKIP:
{
  "%%": DEFAULT
  | < ~[] >  
}


< COMENTARIO >SKIP: {
	"\n":DEFAULT
	| < ~[] >  
}



TOKEN : /* PALABRAS RESERVADAS */
{
  < tCLASE : "clase" >
| < tMETODO : "metodo" >
 | < tPROGRAMA : "programa" >
| < tAND : "and" >
| < tOR : "or" >
| < tNOT : "not" >
| < tPRINCIPIO : "principio" >
| < tFIN : "fin" >
| < tSI : "si" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tFSI : "fsi" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >
| < tMOD : "mod" >
| < tTRUE : "true" >
| < tFALSE : "false" >
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
| < tACCION : "accion" >
| < tVAL : "val" >
| < tREF : "ref" >

}

TOKEN : /* TIPOS DE DATOS */
{
  < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
}



TOKEN : /* OPERADORES */
{
  <  tIGUAL : "=" >
| <  tFIN_SENTENCIA : ";" >
| <  tMAYOR : ">" >
| <  tMENOR : "<" >
| <  tMAI : ">=" >
| <  tMEI : "<=" >
| <  tNI : "<>" >
| <  tOPAS : ":=" >
| <  tMUL : "*" >
| <  tDIV : "div" >
| <  tMAS : "+" >
| <  tMENOS : "-" >
}

TOKEN : /* VALORES */
{
< tIDv: ((( < tLetra > | "_" )(<tLetra> | "_" | <tCifra>)* (<tLetra> | <tCifra>))) "[" (<tCifra>)+ "]" | < tLetra > "[" (<tCifra>)+ "]">
{
  System.out.println("he encontrado un vector");
}
| < tID : ((( < tLetra > | "_" )(<tLetra> | "_" | <tCifra>)* (<tLetra> | <tCifra>))) | < tLetra > >
| < tNUM : (<tCifra>)+ >
| <  tCAR : "\"" (<tLetra> | <tCifra> | <tSigno> | " " | "." | "," | ";" | "*" | ":" | "(" | ")" | "/" | "?"| "�") "\"" >
| <  tCADENA : "\"" (<tLetra> |<tSigno>|<tSigno>| " "|"."|","|";"|"*"|":"|"("|")"|"/"|"?")+  "\"" >
| <  tCifra : ["0"-"9"] >
| <  tLetra: ["a"-"z"] >
| <tSigno: "+" | "-" >
}

/*ANALIZADOR SINTACTICO*/

void programa():
{
  Token programa;
}
{
 try {
	 <tPROGRAMA> programa = <tID>
	 {
	  Simbolo p = new Simbolo();
	  p = tabla_simbolos.introducir_programa(programa.image,dir);
	  //Escribimos en el fichero de codigo intermedio el programa
	  System.out.println("Voy a escribir probrama en .code");
	  
	  pw.println("; Programa " + programa.image + ".");
	  //Introducimos la primera intruccion de inicio de programa
	  String et_p = et.nueva_et();
	  pw.println("	ENP  " + et_p);
	  
	  //tabla_simbolos.imprimirTabla();
	 }";" 
	 declaracion_variables()
	 {
	   pw.println("; Comienzo del programa " + programa.image);
	 }
	 declaracion_acciones()
	 {
	   pw.println(et_p + ":");
	 }
	 bloque_sentencias(p, et_p)
	 {
		pw.println("; Fin del programa " + programa.image);
      	pw.println("LVP");
	 }
	 {
	   pw.close();
	 }
 }catch (ParseException e) {
//    System.out.println("1");
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la creacion del programa");
  }
}



void declaracion_variables():
{
}
{ try {
    (declaracion()";")*
  } catch (ParseException e) {
      //TODO: idea->crear una variable booleana que indique que ha ocurrido un error
          SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la declaracion de variables");
    }
}

void declaracion():
{
  Simbolo.Tipo_variable tipo;
}
{ 
  tipo = tipo_variables() (identificadores(tipo))
}

Simbolo.Tipo_variable tipo_variables():
{
}
{ try {
  < tENTERO >	{return Simbolo.Tipo_variable.ENTERO;}
  | < tBOOLEANO >	{return Simbolo.Tipo_variable.BOOLEANO;}
  | < tCARACTER > {return Simbolo.Tipo_variable.CHAR;}
} catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el tipo de las variables");
  }
}

//TODO: cambiar tama�o de la variable del vector por TIPO * longitud
void identificadores(Simbolo.Tipo_variable tipo):
{
  Token id1 = null;
  Token id2 = null;
  //Vectores
  Token id1v = null;
  Token id2v = null;
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
}
{
  try {
  	 ( (id1 = < tID > | id1v = < tIDv >))
	  {
	    try {
	      	//Caso es un vector
	        if(id1 == null) {
	          	  //Obtencion de la longitud del vector
		          int i = id1v.image.length()-2;
		          while( id1v.image.charAt(i) != '[') {
			            i--;
		          }
		          String tam_vec = id1v.image.substring(i+1,id1v.image.length()-1);
		          s1 = tabla_simbolos.introducir_variable(id1v.image,tipo,nivel,dir,true,Integer.parseInt(tam_vec));
		          System.out.println("Voy a aumentar el tama�o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
				  dir += s1.get_tamanyo();
		          System.out.println(id1v.image);
	        }else { 
		      	s1 = tabla_simbolos.introducir_variable(id1.image,tipo,nivel,dir,false,0);
				System.out.println("Voy a aumentar el tama�o en: " +s1.get_tamanyo()+ " por "+ s1.getNombre());
				dir += s1.get_tamanyo();
			}
	  	}catch(SimboloYaDeclaradoException e2) {
	  	  	System.out.println("Error  semantico");
	  	}
	  }

  	("," ( id2 = < tID > | id2v = < tIDv >)
  	{
	    try {
	      if(id2 == null) {
	          	  //Obtencion de la longitud del vector
		          int i = id2v.image.length()-2;
		          while( id2v.image.charAt(i) != '[') {
			            i--;
		          }
		          String tam_vec = id2v.image.substring(i+1,id2v.image.length()-1);
		          s2 = tabla_simbolos.introducir_variable(id2v.image,tipo,nivel,dir,true,Integer.parseInt(tam_vec));
		          System.out.println("Voy a aumentar el tama�o en: " +s2.get_tamanyo()+ " por "+ s2.getNombre());
				  dir += s2.get_tamanyo();
		          System.out.println(id1v.image);
	        }else { 
		      	s2 = tabla_simbolos.introducir_variable(id2.image,tipo,nivel,dir,false,0);
				System.out.println("Voy a aumentar el tama�o en: " +s2.get_tamanyo()+ " por "+ s2.getNombre());
				dir += s2.get_tamanyo();
			}
	  	}catch(SimboloYaDeclaradoException e2) {
	  	  	System.out.println("Error  semantico");
	  	}
	  }
  	)*
  
  } catch (ParseException e) {   
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el identificador");
  }
}

void declaracion_acciones():
{
}
{
  (declaracion_accion())*
}


// (cabecera_accion())";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias())
void declaracion_accion():
{
  	 String etACC = et.nueva_et();
	 Simbolo sim = new Simbolo();
	 String s = new String();
}
{
  (sim = cabecera_accion(etACC))";"(declaracion_variables()) (declaracion_acciones()) (bloque_sentencias(sim,etACC))
  {

    	
    	pw.println("; Fin de la accion " + s);
     	pw.println("CSF");
	    //tabla_simbolos.imprimirTabla();
	    //System.out.println("Voy a eliminar las variables del nivel " + nivel);
	    tabla_simbolos.eliminar_variables(nivel);
	    //System.out.println("Voy a eliminar acciones");
	    tabla_simbolos.ocultar_parametros(nivel);
	    tabla_simbolos.eliminar_acciones(nivel);
	    tabla_simbolos.eliminar_parametros_ocultos(nivel+1);
	    nivel--;
  }
}

Simbolo cabecera_accion(String etACC):
{
    Token id_accion;
    Simbolo simbolo_accion = null;
    boolean ok;
}
{
  ((<tACCION> id_accion = <tID>
  {
    try {
      	//Justo despues de registrar la accion en la tabla de simbolos, incrementamos el nivel en uno.
      	simbolo_accion = tabla_simbolos.introducir_accion(id_accion.image,nivel,dir,etACC/*TODO: mirar lo de las direcciones*/);
      	
      	//System.out.println("Voy a aumrntar el nivel " + (nivel +1));
      	dir = INICIAL;
	    nivel++;
	   
	}catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("Error  semantico");
	}
  }
  //le pasamos a los parametros formales el simbolo de la accion a la que pertenecen para asi poder relacionarlos.
  ) parametros_formales(simbolo_accion))
  {
    return simbolo_accion;
  }
}

void parametros_formales(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos pasando el simbolo de la accion para poder asiciarla con los parametros
	("("(lista_parametros(simbolo_accion))")")?
  } catch (ParseException e) {   
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros formales");
  }
}

void lista_parametros(Simbolo simbolo_accion):
{
}
{ try {
  	//Seguimos propagando el simbolo de la accion para poder asociarla
	parametros(simbolo_accion)(";"parametros(simbolo_accion))*
  } catch (ParseException e) {
       SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de parametros");
  }
}


void parametros(Simbolo simbolo_accion):
{
  Simbolo.Clase_parametro clase;
  Simbolo.Tipo_variable tipo;
  Token id1;
  Token id2;
  Simbolo param;
  Simbolo param2;
}
{ try {
  	//Obtenemos la clase y el timpod el parametro que queremos introducir
	(clase = clase_parametros() tipo = tipo_variables()  id1 = < tID >
	{
	  try {
	    //System.out.println("Voy a introduxir un parametro" + simbolo_accion.getNombre() +" "+ id1.image);
	    //introducimos el parametro actual en la tabla de simbolos
	    param = tabla_simbolos.introducir_parametro(id1.image,tipo, clase, nivel,dir);

	    //Introducimos el parametro a la lista de los parametros del simbolo de la accion he hemos ido propagando
	    simbolo_accion.addParametro(param);
	    //System.out.println("A�adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
	    
	    
	    
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("El simbolo declarado ya existe");
	  }
	}



	(","id2 = < tID >
	{
	  try {
	    param2 = tabla_simbolos.introducir_parametro(id2.image,tipo, clase, nivel, dir/*aqui va la direccion*/);
	    simbolo_accion.addParametro(param2);

	    //System.out.println("A�adido nuevo parametro a la accion:" +simbolo_accion.getListaParametros().toString());
	    
	  }catch(SimboloYaDeclaradoException e2) {
	  	System.out.println("Error  semantico");
	  }
	}
	)*)
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en los parametros");
  }
}

Simbolo.Clase_parametro clase_parametros():
{
}
{ try {
	(< tVAL > {return Simbolo.Clase_parametro.VAL; }
	| < tREF >){return Simbolo.Clase_parametro.REF; }
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la clase de parametros");
  }
}

void bloque_sentencias(Simbolo s, String etACC):
{
  //Lista necesaria para recuperar los parametros en la invicacion de la accion
  ArrayList<Simbolo> lista_param = new ArrayList<Simbolo>();
}
{ try {
  	{
  	  
  	  //Generamos nueva etiqueta para el comienzo de las acciones de la accion
  	  
  	  
	  //Es una accion hay una etiqueta para saber donde empiezan las intrucciones de la accion
  	  if(!s.ES_PROGRAMA()) {
  	    pw.println(";Accion " + s.getNombre());
  	    pw.println(etACC+":");
  	  }

	  //Obtenemos los parametros de la accion
  	  lista_param = s.getListaParametros();
  	  //Recorremos la lista de forma inversa porque los parametros estan apilados al reves
  	  Simbolo p = new Simbolo();
  	  if(lista_param!= null) { 
	  	  for (int j = lista_param.size() - 1; j >= 0; j--)
	      {
	         p = lista_param.get(j);
	         pw.println("; rec. parametro " + p.getNombre() + " de tipo " + p.getVariable().toString() + 
	         " pasado por " + p.getParametro().toString());
	         pw.println("\t SRF   " + (nivel - p.getNivel()) + "  " + p.getDir());
	         pw.println("\t ASGI");
	      }
	  }

  	}
	(< tPRINCIPIO > lista_sentencias() < tFIN >)
	{
	  //tabla_simbolos.imprimirTabla();
	 }
  } catch (ParseException e) {
//    System.out.println("1");
    
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el bloque de sentencias");
  }
}
void lista_sentencias():
{
}
{ 
	sentencia()(sentencia())*
}

void sentencia():
{
  Token id;
  Simbolo simbolo_id = new Simbolo();
  Simbolo.Tipo_variable tpID;
}
{
 (leer() ";"
 | escribir() ";"
 | id = < tID >
 {
   //System.out.println("Voy a buscar el simbolo:" + id.image +"\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
   //tabla_simbolos.imprimirTabla();
   simbolo_id = tabla_simbolos.buscar_simbolo(id.image);
   if(simbolo_id == null) {
     	System.out.println("Error semantico, no existe el simbolo con nombre: " + id.image +" en la tabla de simbolos");
     	tpID = Simbolo.Tipo_variable.DESCONOCIDO;
   }
   else if(simbolo_id.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && simbolo_id.getParametro() == Simbolo.Clase_parametro.VAL) {
		 System.out.println("Error semantico, no se puede asignar un valor a un parametro por valor");
		 //TODO: Mirar si esto tiene que ir aqui o en asignacion, y si se tiene que poner el tpId a desconocido para seguir la ejecucuion
		 tpID = Simbolo.Tipo_variable.DESCONOCIDO;
   }else {
     tpID = simbolo_id.getVariable();
   }
 }
 (asignacion(simbolo_id,tpID)|invocacion_accion(simbolo_id,tpID))
 |seleccion ()
 | mientras_que())
}

void leer():
{
}
{ try {
  <tLEER> {pw.println("; Lectura"); }
  "(" lista_asignables() ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al leer");
  }
}


void lista_asignables():
{
  Token t1 = new Token();
  Token t2 = new Token();
  Simbolo s1 = new Simbolo();
  Simbolo s2 = new Simbolo();
}
{ try {
  t1 = <tID>
  {
    //Obtenemos el simbolo con el nombre del id
    s1 = tabla_simbolos.buscar_simbolo(t1.image);
    if(s1 == null){
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(s1.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s1.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
  		System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
  	}else if(s1.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s1.getParametro() == Simbolo.Clase_parametro.VAL){
  	    System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
  	}else if(s1.ES_VARIABLE()){
  	  //Obtenemos la variable
  	  	pw.println("; Leer variable " + s1.getNombre());
      	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
      	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
    		pw.println("\t RD    1");
  	  	}
  	  	else{
  	  		pw.println("\t RD    0");
  		}
  	}else if(s1.ES_REFERENCIA()) {
  	 	pw.println("; Leer parametro por referencia " + s1.getNombre());
      	pw.println("\t SRF   " + (nivel - s1.getNivel()) + "  " + s1.getDir());
      	pw.println("\t DRF");
      	if (s1.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
			pw.println("\t RD    1");
	  	}
	  	else{
	  		pw.println("\t RD    0");
		}
  	}
  }
  ( "," t2 = <tID>
  {
	s2 = tabla_simbolos.buscar_simbolo(t2.image);
    if(s2 == null){
    	System.out.println("El simbolo que se esta buscando no esta en la tabla");
  	}else if(s2.getTipo() !=  Simbolo.Tipo_simbolo.PARAMETRO &&  s2.getTipo() != Simbolo.Tipo_simbolo.VARIABLE){
  		System.out.println("El simbolo introducido noe s ni una variable ni un parametro");
  	}else if(s2.getTipo() == Simbolo.Tipo_simbolo.PARAMETRO && s2.getParametro() == Simbolo.Clase_parametro.VAL){
  	    System.out.println("El simbolo es un parametro pero esta pasado por valor nos e puede asignar");
  	}else if(s2.ES_VARIABLE()){
  	  //Obtenemos la variable
  	  	pw.println("; Leer variable " + s2.getNombre());
     	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
     	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
			pw.println("\t RD    1");
		}
		else{
			pw.println("\t RD    0");
		}
  	}else if(s2.ES_REFERENCIA()) {
  	  	pw.println("; Leer parametro por referencia " + s2.getNombre());
      	pw.println("\t SRF   " + (nivel - s2.getNivel()) + "  " + s2.getDir());
      	pw.println("\t DRF");
      	if (s2.getVariable() == Simbolo.Tipo_variable.ENTERO){ 
			pw.println("\t RD    1");
		}
		else{
			pw.println("\t RD    0");
		}
  	}
  }

  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de asignables");
  }
}

void escribir():
{
}
{ try {
  <tESCRIBIR> { pw.println("; Escritura");}
  "(" lista_escribibles() ")"
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo al escribir");
  }
}


void lista_escribibles():
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  
}
{ try {
  r1 = expresion()
  {
    if(r1.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
       	System.out.println("No se puede escribir un tipo desconocido");
    }else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		//TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r1.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra

      	for (int x=1;x<r1.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r1.cadena.charAt(x));
	   		pw.println("	WRT		0");
	  	}
	}
	else if (r1.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r1.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}
  }
  (","r2 = expresion()
  {
	   if(r2.tipo ==  Simbolo.Tipo_variable.DESCONOCIDO) {
	       System.out.println("No se puede escribir un tipo desconocido");
	   }else if(r2.tipo == Simbolo.Tipo_variable.BOOLEANO) { 
		//TODO mirar escribir verdaddero si es true o falso si es false
    }else if(r2.tipo == Simbolo.Tipo_variable.CADENA){
      	//Recorrer la cadena escribiendo letra por letra
      	
      	for (int x=1;x<r2.cadena.length()-1;x++) { 
	   		pw.println("	STC		" + (int)r2.cadena.charAt(x));  
	   		pw.println("	WRT		0");
	   	}
	}
	else if (r2.tipo == Simbolo.Tipo_variable.ENTERO){
	 	pw.println("	WRT		1");
	}else if (r2.tipo == Simbolo.Tipo_variable.CHAR){
	 	pw.println("	WRT		0");
	}
  }
  )*
  } catch (ParseException e) {
        SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de escribibles");
  }
}

void invocacion_accion(Simbolo id, Simbolo.Tipo_variable tpID):
{
  ArrayList<Simbolo > parametros_necesarios = id.getListaParametros();
  //System.out.println("Se va a invocar una accion cuyos parametros son: "+ parametros_necesarios.toString());
}
{ try {
  argumentos(id,tpID,parametros_necesarios) ";"
  {
     pw.println("; Invocando a " + id.getNombre().toUpperCase());
     pw.println("\t OSF   " + (id.getDir() - 1) + "  " + (nivel - id.getNivel())+ " " + id.getEtiqueta());
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la invocacion de acciones");
  }
}

void asignacion(Simbolo id, Simbolo.Tipo_variable tpID/*Esto igual es inutil*/):
{
  RegistroExpr r1 = new RegistroExpr();
  Simbolo.Tipo_variable tpExp;
  Token t;
}
{ try {
  {
    if(id.ES_ACCION()){
    	//TODO: excepciones
    	System.out.println("No se puede asignar una expresion a una accion");
    }else if(id.ES_REFERENCIA()) {
      	pw.println("; Direccion del parametro por referencia " + id.getNombre());
        pw.println("	SRF   " + (nivel - id.getNivel()) + "  " + id.getDir());
        pw.println("	DRF");
    }else {
      //Es una variable normal
      pw.println("; Direccion de la variable " + id.getNombre());
      pw.println("	SRF   " + (nivel - id.getNivel()) + "  " + id.getDir());
    }
  }
  t = <tOPAS> r1 = expresion()
  {
    System.out.println("OPAS");
    if(r1.tipo == Simbolo.Tipo_variable.ENTERO) {
		System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorEnt);
  	}else if(r1.tipo == Simbolo.Tipo_variable.CHAR) {
  	  	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorChar);
  	}else if(r1.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
  	  	System.out.println("Se va a asignar un " + r1.tipo.toString());
  	}else if(r1.tipo == Simbolo.Tipo_variable.BOOLEANO) {
  	 	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.valorBool);
  	}else if(r1.tipo == Simbolo.Tipo_variable.CADENA) {
  	  	System.out.println("Se va a asignar un " + r1.tipo.toString() + " con valor: " + r1.cadena);
  	}

    //Hay que mirar que los tipos sean asignables y que coincidan ambos tipos
  	if(id.getVariable() != r1.tipo && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
  		//TODO: excepciones
      	System.out.println("No se puede asignar porque los tipos no coinciden " + id.getVariable().toString()+" " + id.getNombre() + " " + r1.tipo.toString());
   	}else if( r1.tipo == Simbolo.Tipo_variable.CADENA) {
   		//TODO: excepciones
   		//Caso especial las cadenas solo sirven en escribirss
      	System.out.println("No se pueden asignar las cadenas, solo para escritura");
   	}

	//Si todo va bien hacemos la asignacion
   	pw.println("; Asignacion.");
    pw.println("	ASG");
	
  }
  ";"
  } catch (ParseException e) {
     SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en asignacion");
  }
}


void mientras_que():
{
   RegistroExpr r = new RegistroExpr();
}
{ try {
  <tMQ>
  {
    
    String etMQ = et.nueva_et();
    pw.println(";MQ");
    pw.println(etMQ + ":");
  }
  r = expresion()
  {
       String etFIN = et.nueva_et();
       pw.println("	JMF	" + etFIN);
  	   if(r.tipo != Simbolo.Tipo_variable.BOOLEANO) {
		//TODO: gestionar excepciones
		System.out.println("La condicion del mientras que no es un booleano");
    }
  }
  lista_sentencias() <tFMQ>
  {
     
     pw.println("	JMP	" + etMQ);
     pw.println(";FMQ");
     pw.println(etFIN + ":");
     
    
  }
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en mientras que");
  }
}

void seleccion():
{
   RegistroExpr r = new RegistroExpr();
  
}
{ try {
  <tSI> {pw.println(";SI" );}
  r = expresion()
  {
    
    String etiqSINO = et.nueva_et();
    //TODO: mirar etiqueta sino si no hay sino
    pw.println("	JMF " + etiqSINO);
    if(r.tipo == Simbolo.Tipo_variable.BOOLEANO && !r.esVariable){
      //TODO mirar este if si hay que ejecutarlo
     	if(r.valorBool) {
     	 	System.out.println("Este codigo siempre se va a ejecutar porque es una constante TRUE");
     	}else {
			System.out.println("Este codigo nunca se va a ejecutar porque es una constante FALSE");	
     	}
        
    }else if(r.tipo != Simbolo.Tipo_variable.BOOLEANO ) {
		//TODO: gestionar excepciones
		System.out.println("La condicion de la seleccion no es un booleano");
    }
  }
  <tENT> { pw.println(";ENT" );}
  lista_sentencias()
  {
    
    String etiqFIN= et.nueva_et();
    pw.println("	JMP " + etiqFIN);
    pw.println(etiqSINO +":" );
  }
  ( <tSI_NO>
  {
    
    pw.println(";SI_NO" );
  }
  lista_sentencias() )? <tFSI>
  {
    pw.println(etiqFIN +":" );
    pw.println(";FSI" );
  }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en seleccion");
  }
}

void argumentos(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params;
}
{ try {
 ("(" (params = lista_expresiones(id,tpID,parametros_necesarios)
 {
    //TODO: pruebas con distintas funciones
   	if(params.size() != parametros_necesarios.size()) {
   	  	//TODO: gestionar excepciones 
		System.out.println("Los parametros patra invocar a la accion no coinciden "+ params.size() + " , " + parametros_necesarios.size());
   	}else {
   	  	Simbolo s = new Simbolo();
   	  	RegistroExpr r = new RegistroExpr();
   	  	int num_params = params.size();
   	  	//TODO: mirar si hay que hacer alguna comprobacion mas, por ejemplo DESCONOCIDO
   	  	for( int i = 0; i < num_params; i++) {
			s = parametros_necesarios.get(i);
			r = params.get(i);
			//System.out.println("Parametro numero " + i + " tipo_necesario: "+ s.getVariable().toString() + " tipo_pasado: " + r.tipo.toString());
			if(s.getVariable() != r.tipo) {
				//TODO: gestionar excepciones
				System.out.println("Los tipos de los argumentos no coinciden");
			}else if(s.getParametro() == Simbolo.Clase_parametro.REF && !r.esVariable) {
			  	//TODO: gestionar excepciones
			  	System.out.println("Se esperaba un parametro por referecncia, no por valor");
			} 
   	  	}
   	}

 }
  )? ")")?
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en argumentos");
  }
}


//TODO: Hacer un programa para probar esto, devuelve una lista de RegistroExpresiones
//TODO: igual no hace falta pasar tantos parametros hasta esta funcion
ArrayList<RegistroExpr> lista_expresiones(Simbolo id, Simbolo.Tipo_variable tpID,ArrayList<Simbolo > parametros_necesarios):
{
  ArrayList<RegistroExpr > params = new ArrayList<RegistroExpr>();
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new RegistroExpr();
  
}
{ try {
  r1 = expresion()
  {
    params.add(r1);
  }
  ( "," r2 = expresion()
  {
    params.add(r2);
  }
  )*
 {
   return params;
 }
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en la lista de expresiones");
  }
}


Token operador_multiplicativo():
{
  Token t;
}
{ try {
  ( t = <tMUL>{return t;}
  | t = <tAND>{return t;}
  | t = <tDIV>{return t;}
  | t = <tMOD>{return t;}
  )
  } catch (ParseException e) {
   SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador multiplicativo");
  }
}

Token operador_aditivo():
{
  Token t;
}
{ try {
  ( t = <tMAS>{return t;}
  | t = <tMENOS>{return t;}
  | t = <tOR>{return t;}
  )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador aditivo");
  }
}

Token operador_relacional():
{
  Token t;
}
{ try {
  ( t = <tMAYOR>{return t;}
  | t = <tMENOR>{return t;}
  | t = <tIGUAL>{return t;}
  | t = <tMAI>{return t;}
  | t = <tMEI>{return t;}
  | t = <tNI>{return t;}
   )
  } catch (ParseException e) {
    SyntaxErrorManager.printSyntaxError(e.currentToken.next,e.expectedTokenSequences,e.tokenImage, "fallo en el operador relacional");
  }
}

//TODO: hacer que se pueda hacer mayor menor de caracteres, cadenas, etc??
RegistroExpr expresion():
{ 
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  	r1 = expresion_simple()
  	{
  	  //System.out.println("El tipo de r1 es: " + r1.tipo.toString());
	  result = r1;
  	}
  	( t = operador_relacional() r2 = expresion_simple() 
  	{
  	  boolean ok = true;
 
	  String operacion = t.image;
//	  if(operacion != null) { 
		  switch(operacion) { 
		  		case ">":
		  			pw.println("	GT");
		  			//System.out.println("Detectado >");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede >");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede >");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt > r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<":
		  			pw.println("	LT");
		  			//System.out.println("Detectado <");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt < r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case ">=":
		  			pw.println("	GTE");
		  			//System.out.println("Detectado >=");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede >=");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede >=");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt >= r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<=":
		  			pw.println("	LTE");
		  			//System.out.println("Detectado <=");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <=");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <=");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt <= r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		//TODO: mirar el < > y en = si se puede hacer con booleanos, cadenas, caracteres
		  		case "=":
		  			pw.println("	EQ");
		  			//System.out.println("Detectado =");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede =");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede =");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt == r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "<>":
		  			pw.println("	NEQ");
		  			//System.out.println("Detectado <>");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede <>");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede <>");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorEnt != r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }
  	}
  	)* {
  	  //System.out.println("Voy a devolver result:" + result.tipo);
  	  return result;
  	  }
}

RegistroExpr expresion_simple():
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
	r1 = termino() {
	  //System.out.println("primero");
      result = r1;
	  
	}(t = operador_aditivo() r2 = termino()
	{

	 
	  boolean ok = true;
	  String operacion = t.image;
		  switch(operacion.toLowerCase()) { 
		  		case "+":
		  			pw.println("	PLUS");
		  			//System.out.println("Detectado +");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede sumar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede sumar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de overflow,underflow etc etc
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt + r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "-":
		  			pw.println("	SBT");
		  			//System.out.println("Detectado -");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede restar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede restar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobacionesde modulo por 0
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt - r2.valorEnt; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
	  				//return result;
					break;
		  		case "or":
		  			pw.println("	OR");
		  			//System.out.println("Detectado and");
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer or");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es booleano o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer or");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorBool | r2.valorBool; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  }

	}
	)*
	{
	  //System.out.println("Voy a devolver result:" + result.tipo);
	  return result;
	}
}


RegistroExpr termino():
{
  RegistroExpr r1 = new RegistroExpr();
  RegistroExpr r2 = new  RegistroExpr();
  RegistroExpr ant = new  RegistroExpr();
  Token t = new Token();
  RegistroExpr result = new RegistroExpr();
}
{
  
  r1 = factor()
  {
    //System.out.println("primero");
    //Si solo es un valor devolvemos ese valor solo
    result = r1;
    ant = r1;
  }

  ( t = operador_multiplicativo() r2 = factor()
  { 
	  boolean ok = true;
	  //System.out.println("segundo");
	  String operacion = t.image;
  		  //Hay que hacer lowercase porque aunque el analizador sea case insensitive, el switch reconoce la diferencia entre mayusculas y minusculas
		  switch(operacion.toLowerCase()) { 
		  		case "*":
		  			pw.println("	TMS");
		  			//System.out.println("Detectado *");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede multiplicar");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede multiplicar");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				    System.out.println("Voy a multiplicar: " + result.valorEnt + " y " + r2.valorEnt);
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt * r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt * r2.valorEnt;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "mod":
		  			pw.println("	MOD");
		  			//System.out.println("Detectado mod");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede hacer mod");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede hacer mod");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  			  //Mirar si esto va bien
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				    if(!r2.esVariable) {
		  				      	System.out.println("Voy a mod de constante: " + result.valorEnt + " y " + r2.valorEnt);
		  				      	if(r2.valorEnt == 0) {
		  				      	  	//TODO: Gestionar excepciones de modulo 0
		  				      	  	System.out.println("Es modeulo 0");
		  				      	}else {
		  				      	  	result.valorEnt =	result.valorEnt % r2.valorEnt;
		  				      	}
		  					}else {
		  					  	//TODO: Mirar que hay que hacer aqui
//		  					    System.out.println("regexpr "+r2.esVariable);
//		  					  	result.tipo =  Simbolo.Tipo_variable.ENTERO;
//		  						result.valorEnt =	result.valorEnt % r2.valorEnt;
		  					}
		  				  	
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
					break;
		  		case "div":
		  			pw.println("	DIV");
		  			System.out.println("Detectado /");
		  			if(r1.tipo != Simbolo.Tipo_variable.ENTERO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es entero por lo tanto no se puede dividir");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.ENTERO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es entero por lo tanto no se puede dividir");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  				  //TODO: hay que hacer las comprobaciones de division por 0
		  				  	System.out.println("Voy a dividir: " + result.valorEnt + " y " + r2.valorEnt);
		  					result.tipo =  Simbolo.Tipo_variable.ENTERO;
		  					result.valorEnt =	result.valorEnt / r2.valorEnt;
//		  					ant.valorEnt = ant.valorEnt / r2.valorEnt;
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  		case "and":
		  			pw.println("	AND");
		  			//System.out.println("Detectado and");
		  			if(r1.tipo != Simbolo.Tipo_variable.BOOLEANO && r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		  			  	System.out.println("El primero de los valores no es booleano por lo tanto no se puede hacer and");
		  			  	ok = false;
		  			}
		  			if(ok){ //El primer parametro es entero o desconocido
		  				if(r2.tipo != Simbolo.Tipo_variable.BOOLEANO && r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			  			  	System.out.println("El segundo de los valores no es booleano por lo tanto no se puede hacer and");
			  			  	ok = false;
		  				}
		  			} 
		  			if(ok) {
		  				if(r1.tipo != Simbolo.Tipo_variable.DESCONOCIDO &&  r2.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
							System.out.println("Voy a and: " + result.valorBool + " y " + r2.valorBool);
		  					result.tipo =  Simbolo.Tipo_variable.BOOLEANO;
		  					result.valorBool =	result.valorBool && r2.valorBool;
		  					System.out.println("salgo de and");
//		  					ant.valorBool = r1.valorBool && r2.valorBool; 
		  				}else {
		  				  	result.tipo =  Simbolo.Tipo_variable.DESCONOCIDO;
		  				}
		  			}
		  			break;
		  			
		  }
  }
  )*
  {
    //System.out.println("Voy a devolver result:" + result.tipo);
    return result;
  }
  
}

/*("-" factor()
	| <tNOT> factor()
	| "(" expresion() ")"
	| <tENTACAR> "(" expresion() ")"
	| <tCARAENT> "(" expresion() ")"
	| <tID>
	| <tNUM>
	| <tCAR>
	| <tCADENA>
	| <tTRUE>| <tFALSE>)*/

RegistroExpr factor():
{
  RegistroExpr re = new RegistroExpr();
  Token t;
  Simbolo s;
}
{
  ("-" re = factor()
  {
    pw.println("	NGBI");
    if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			System.out.println("El tipo de la variable no es compatible con \"-\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.ENTERO) {
		re.valorEnt = -re.valorEnt;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }
  
  | <tNOT> re = factor()
  {
    pw.println("	NGB");
    if(re.tipo != Simbolo.Tipo_variable.BOOLEANO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
			System.out.println("El tipo de la variable no es compatible con \"NOT\" ");
			//TODO: mirar si hay que lanzar una excepcion o hacer algo mas
			//Hay que devolver un Registro expr que sea de tipo desconocido??
    }
    else if(re.tipo == Simbolo.Tipo_variable.BOOLEANO) {
		re.valorBool = !re.valorBool;
		return re;
    }else {
      //Caso en el que el tipo de la variable es desconocido.
      return re;
    }
  }

  //TODO: descomentar esto cuando ya vaya expresion
  | "(" re = expresion() ")"
  {
    //Si solo hay parentesis hay que devolver lo que hay dentro de los parentesis
    return re;
  }

  
  //TODO: descomentar esto cuando ya vaya expresion
  | t = <tENTACAR> "(" re =expresion() ")"
  {
  	if(re.tipo != Simbolo.Tipo_variable.ENTERO && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.CHAR;
		new_r.valorChar = (char)re.valorEnt;
		return new_r;
    }
    
    
    
  }
  | <tCARAENT> "(" re = expresion() ")"
  {
    if(re.tipo != Simbolo.Tipo_variable.CHAR && re.tipo != Simbolo.Tipo_variable.DESCONOCIDO) {
		System.out.println("El valora pasado a entacar con es ni entero ni deconocido");
    }else if( re.tipo == Simbolo.Tipo_variable.DESCONOCIDO) {
      	//Si no sabemos el tipo propagamos lo que nos han pasado
		return re;
    }else {
      	RegistroExpr new_r = new  RegistroExpr();
      	new_r.tipo= Simbolo.Tipo_variable.ENTERO;
		new_r.valorEnt = (int)re.valorChar;
		return new_r;
    }
    
  }
  | t = <tID>
  {
     s = tabla_simbolos.buscar_simbolo(t.image);
     if(s == null) {
       //TODO: no existe el simbolo hay que lanzar una exepcion
     }else if(s.ES_ACCION()) {
       //TODO: no existe el simbolo hay que lanzar una exepcion
     }else {
       	 pw.println("; Acceso a la variable " + s.getNombre());
       	 pw.println("	SRF	"+  (nivel - s.getNivel()) + "	" + s.getDir());
       	 pw.println("	DRF");
	     re.tipo = s.getVariable();
	     re.s = s.getTipo();
	     re.esVariable = true;
	     return re;
	}
     
  }
  | t  = <tNUM>
  {
     pw.println("	STC   " + t.image);
     return RegistroExpr.ENTERO(t.image);
  }
  | t = <tCAR>
  {
     pw.println("	STC   " + t.image);
     return RegistroExpr.CHAR(t.image);
  }
	
  | t = <tCADENA>
  {
     pw.println(";cadena	" + t.image);
     return RegistroExpr.CADENA(t.image);
  }
  | <tTRUE>
  {
     pw.println("	STC   1" );
     return RegistroExpr.BOOL(true);
  }
  | t = <tFALSE>)
  {
     pw.println("	STC   0" );
     return RegistroExpr.BOOL(false);
  }
}

